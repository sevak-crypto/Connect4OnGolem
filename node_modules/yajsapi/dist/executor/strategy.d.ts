import { Activity } from "../props";
import { DemandBuilder } from "../props/builder";
import { Counter } from "../props/com";
import { OfferProposal } from "../rest/market";
export declare const SCORE_NEUTRAL: number;
export declare const SCORE_REJECTED: number;
export declare const SCORE_TRUSTED: number;
export interface ComputationHistory {
    rejected_last_agreement: (string: any) => boolean;
}
export declare class MarketStrategy {
    decorate_demand(demand: DemandBuilder): Promise<void>;
    score_offer(offer: OfferProposal, history?: ComputationHistory): Promise<Number>;
}
interface MarketGeneral extends MarketStrategy, Object {
}
declare class MarketGeneral {
}
export declare class DummyMS extends MarketGeneral {
    max_for_counter: Map<Counter, Number>;
    max_fixed: Number;
    _activity?: Activity;
    decorate_demand(demand: DemandBuilder): Promise<void>;
    score_offer(offer: OfferProposal, history?: ComputationHistory): Promise<Number>;
}
export declare class LeastExpensiveLinearPayuMS {
    private _expected_time_secs;
    private _max_fixed_price?;
    private _max_price_for?;
    constructor(expected_time_secs?: number, max_fixed_price?: number, max_price_for?: Map<Counter, number>);
    decorate_demand(demand: DemandBuilder): Promise<void>;
    score_offer(offer: OfferProposal, history?: ComputationHistory): Promise<Number>;
}
export declare class DecreaseScoreForUnconfirmedAgreement {
    private _base_strategy;
    private _factor;
    constructor(base_strategy: any, factor: any);
    decorate_demand(demand: DemandBuilder): Promise<void>;
    score_offer(offer: OfferProposal, history?: ComputationHistory): Promise<Number>;
}
export {};
