"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiConfigProvider = exports.CommandExecutionError = exports.ActivityService = void 0;
const eventsource_1 = __importDefault(require("eventsource"));
const base_1 = require("ya-ts-client/dist/ya-activity/base");
const api_1 = require("ya-ts-client/dist/ya-activity/api");
const sgx_ias_js_1 = require("sgx-ias-js");
const models_1 = require("ya-ts-client/dist/ya-activity/src/models");
const crypto_1 = require("../crypto");
const utils_1 = require("../utils");
const events = __importStar(require("../executor/events"));
const sgx_1 = require("../package/sgx");
const utf8 = __importStar(require("utf8"));
const dayjs_1 = __importDefault(require("dayjs"));
class ActivityService {
    constructor(cfg) {
        this._api = new api_1.RequestorControlApi(cfg);
        this._state = new api_1.RequestorStateApi(cfg);
    }
    async new_activity(agreement, secure = false) {
        try {
            if (secure) {
                return await this._create_secure_activity(agreement);
            }
            else {
                return await this._create_activity(agreement.id());
            }
        }
        catch (error) {
            utils_1.logger.warn(`Failed to create activity for agreement ${agreement.id()}: ${error}`);
            throw error;
        }
    }
    async _create_activity(agreement_id) {
        let { data: response } = await this._api.createActivity({ agreementId: agreement_id }, { timeout: 30000, params: { timeout: 25 } });
        let activity_id = typeof response == "string" ? response : response.activityId;
        return new Activity(activity_id, this._api, this._state);
    }
    async _create_secure_activity(agreement) {
        let priv_key = new crypto_1.PrivateKey();
        let pub_key = priv_key.publicKey();
        let crypto_ctx;
        let { data: response } = await this._api.createActivity({
            agreementId: agreement.id(),
            requestorPubKey: pub_key.toString(),
        }, { timeout: 30000, params: { timeout: 25 } });
        let activity_id = typeof response == "string" ? response : response.activityId;
        let credentials = typeof response == "string" ? undefined : response.credentials;
        try {
            if (!credentials) {
                throw Error("Missing credentials in CreateActivity response");
            }
            if (pub_key.toString() != credentials.sgx.requestorPubKey) {
                throw Error("Invalid requestor public key in CreateActivity response");
            }
            let enclave_key = crypto_1.PublicKey.fromHex(credentials.sgx.enclavePubKey);
            crypto_ctx = await crypto_1.CryptoCtx.from(enclave_key, priv_key);
            if (sgx_1.SGX_CONFIG.enableAttestation) {
                await this._attest(activity_id, agreement, credentials);
            }
        }
        catch (error) {
            await this._api.destroyActivity(activity_id, { timeout: 11000, params: { timeout: 10 } });
            throw error;
        }
        return new SecureActivity(activity_id, credentials.sgx, crypto_ctx, this._api, this._state);
    }
    async _attest(activity_id, agreement, credentials) {
        let demand = (await agreement.details()).raw_details.demand;
        let pkg = demand.properties["golem.srv.comp.task_package"];
        if (!pkg) {
            throw new Error("Invalid agreement: missing package");
        }
        let evidence = {
            report: credentials.sgx.iasReport,
            signature: sgx_ias_js_1.types.parseHex(credentials.sgx.iasSig),
        };
        let verifier = sgx_ias_js_1.attest.AttestationVerifier.from(evidence)
            .data(sgx_ias_js_1.types.parseHex(credentials.sgx.requestorPubKey))
            .data(sgx_ias_js_1.types.parseHex(credentials.sgx.enclavePubKey))
            .data(new TextEncoder().encode(pkg))
            .mr_enclave_list(sgx_1.SGX_CONFIG.exeunitHashes)
            .nonce(utf8.encode(activity_id))
            .max_age(sgx_1.SGX_CONFIG.maxEvidenceAge);
        if (!sgx_1.SGX_CONFIG.allowDebug) {
            verifier.not_debug();
        }
        if (!sgx_1.SGX_CONFIG.allowOutdatedTcb) {
            verifier.not_outdated();
        }
        let result = verifier.verify();
        if (result.verdict != sgx_ias_js_1.attest.AttestationVerdict.Ok) {
            let name = result.verdict.toString();
            throw new Error(`Attestation failed: ${name}: ${result.message}`);
        }
    }
}
exports.ActivityService = ActivityService;
class ExeScriptRequest {
    constructor(text) {
        this.text = text;
    }
}
class Activity {
    constructor(id, _api, _state) {
        this._id = id;
        this._api = _api;
        this._state = _state;
    }
    set id(x) {
        this._id = x;
    }
    get id() {
        return this._id;
    }
    get credentials() {
        return this._credentials;
    }
    get exeunitHashes() {
        return sgx_1.SGX_CONFIG.exeunitHashes.map((value) => value.toString());
    }
    async state() {
        let { data: result } = await this._state.getActivityState(this._id);
        let state = result;
        return state;
    }
    async send(script, stream, deadline, cancellationToken) {
        const script_txt = JSON.stringify(script);
        const { data: batch_id } = await this._api.exec(this._id, new ExeScriptRequest(script_txt), { timeout: 5000 });
        if (stream) {
            return new StreamingBatch(this._api, this._id, batch_id, script.length, deadline, cancellationToken);
        }
        return new PollingBatch(this._api, this._id, batch_id, script.length, deadline, cancellationToken);
    }
    async ready() {
        return this;
    }
    async done() {
        try {
            await this._api.destroyActivity(this._id, { timeout: 11000, params: { timeout: 10 } });
        }
        catch (error) {
            utils_1.logger.error(`Got API Exception when destroying activity ${this._id}: ${error}`);
        }
    }
}
class SecureActivity extends Activity {
    constructor(id, credentials, crypto_ctx, _api, _state) {
        super(id, _api, _state);
        this._credentials = credentials;
        this._crypto_ctx = crypto_ctx;
    }
    async send(script, stream, deadline) {
        let cmd = { exec: { exe_script: script } };
        let batch_id = await this._send(crypto_1.rand_hex(32), cmd);
        if (stream) {
            return new StreamingBatch(this._api, this._id, batch_id, script.length, deadline);
        }
        return new PollingBatch(this._api, this._id, batch_id, script.length, deadline);
    }
    async _send(batch_id, cmd, timeout) {
        let req = new SecureRequest(this._id, batch_id, cmd, timeout);
        let req_buf = Buffer.from(JSON.stringify(req));
        let enc_req = this._crypto_ctx.encrypt(req_buf);
        let { data: enc_res } = await this._api.callEncrypted(this._id, "", {
            responseType: "arraybuffer",
            headers: {
                "Content-Type": "application/octet-stream",
                Accept: "application/octet-stream",
            },
            transformRequest: [
                (_headers, _data) => enc_req,
            ],
            timeout: 0,
        });
        let res_buf = this._crypto_ctx.decrypt(Buffer.from(enc_res));
        let res = SecureResponse.from_buffer(res_buf);
        return res.unwrap();
    }
}
class SecureRequest {
    constructor(activityId, batchId, command, timeout) {
        this.activityId = activityId;
        this.batchId = batchId;
        this.command = command;
        this.timeout = timeout;
    }
}
class SecureResponse {
    static from_buffer(buffer) {
        return Object.assign(new SecureResponse(), JSON.parse(buffer.toString()));
    }
    unwrap() {
        if (this.command == "error" || !!this.Err) {
            throw new Error(this.Err || this.Ok);
        }
        return this.Ok;
    }
}
class Result {
}
class CommandExecutionError extends Error {
    constructor(command, message) {
        super(message);
        this.command = command;
        this.message = message || "";
    }
    toString() {
        return this.message;
    }
}
exports.CommandExecutionError = CommandExecutionError;
class BatchTimeoutError extends Error {
}
class Batch {
    constructor(api, activity_id, batch_id, batch_size, deadline, credentials, cancellationToken) {
        this.api = api;
        this.activity_id = activity_id;
        this.batch_id = batch_id;
        this.size = batch_size;
        this.deadline = deadline ? dayjs_1.default.unix(deadline) : dayjs_1.default().utc().add(1, "day");
        this.credentials = credentials;
        this.cancellationToken = cancellationToken;
    }
    milliseconds_left() {
        const now = dayjs_1.default().utc();
        return this.deadline && this.deadline.diff(now, "millisecond");
    }
    id() {
        this.batch_id;
    }
    async *[Symbol.asyncIterator]() { }
}
class PollingBatch extends Batch {
    constructor(api, activity_id, batch_id, batch_size, deadline, cancellationToken) {
        super(api, activity_id, batch_id, batch_size, deadline, undefined, cancellationToken);
    }
    async *[Symbol.asyncIterator]() {
        let last_idx = 0, results = [];
        while (last_idx < this.size) {
            const timeout = this.milliseconds_left();
            if (this.cancellationToken && this.cancellationToken.cancelled) {
                throw new CommandExecutionError(last_idx.toString(), "Interrupted.");
            }
            if (timeout && timeout <= 0) {
                throw new BatchTimeoutError();
            }
            try {
                let { data } = await this.api.getExecBatchResults(this.activity_id, this.batch_id, undefined, { timeout: 5000 });
                results = data;
            }
            catch (error) {
                const timeout_msg = error.message && error.message.includes("timeout");
                if (error.response && error.response.status === 408) {
                    continue;
                }
                else if (error.code === "ETIMEDOUT" || (error.code === "ECONNABORTED" && timeout_msg)) {
                    continue;
                }
                else {
                    if (error.response && error.response.status == 500 && error.response.data) {
                        throw new CommandExecutionError(last_idx.toString(), `Provider might have disconnected (error: ${error.response.data.message})`);
                    }
                    throw error;
                }
            }
            let any_new = false;
            results = results.slice(last_idx);
            for (let result of results) {
                any_new = true;
                if (last_idx != result.index)
                    throw `Expected ${last_idx}, got ${result.index}`;
                const { message, stdout, stderr } = result;
                let _message = "";
                if (message) {
                    _message = message;
                }
                else if (stdout || stderr) {
                    _message = JSON.stringify({ stdout, stderr });
                }
                let evt = Object.create(events.CommandExecuted.prototype);
                evt.cmd_idx = evt.idx = result.index;
                evt.stdout = result.stdout;
                evt.stderr = result.stderr;
                evt.message = result.message;
                evt.command = "";
                evt.success = result.result === models_1.ExeScriptCommandResultResultEnum.Ok;
                yield new events.CommandEventContext(evt);
                last_idx = result.index + 1;
                if (result.isBatchFinished)
                    break;
            }
            if (!any_new)
                await utils_1.sleep(3);
        }
        return;
    }
}
class StreamingBatch extends Batch {
    constructor(api, activity_id, batch_id, batch_size, deadline, cancellationToken) {
        super(api, activity_id, batch_id, batch_size, deadline, undefined, cancellationToken);
    }
    async *[Symbol.asyncIterator]() {
        const activity_id = this.activity_id;
        const batch_id = this.batch_id;
        const last_idx = this.size - 1;
        let config_prov = new ApiConfigProvider(this.api);
        let host = config_prov.base_path();
        let api_key = await config_prov.api_key();
        let evtSource = new eventsource_1.default(`${host}/activity/${activity_id}/exec/${batch_id}`, {
            headers: {
                Accept: "text/event-stream",
                Authorization: api_key ? `Bearer ${api_key}` : undefined,
            },
        });
        let results = [];
        let finished = false;
        let resolve;
        let promise = new Promise((r) => (resolve = r));
        const on_error = (e) => {
            if (!e)
                return;
            let msg = !e["message"] ? "source unavailable" : e["message"];
            utils_1.logger.error("Runtime event source error:", msg);
            cleanup();
        };
        const on_event = (e) => {
            try {
                results.push(events.CommandEventContext.fromJson(e["data"]));
                resolve();
                promise = new Promise((r) => (resolve = r));
            }
            catch (e) {
                utils_1.logger.warn("Runtime event error:", e);
            }
        };
        const cleanup = () => {
            evtSource.removeEventListener("error", on_error);
            evtSource.removeEventListener("runtime", on_event);
            evtSource.close();
            finished = true;
            resolve();
        };
        evtSource.addEventListener("error", on_error);
        evtSource.addEventListener("runtime", on_event);
        while (!finished) {
            await promise;
            for (let result of results) {
                yield result;
                if (result.computation_finished(last_idx)) {
                    finished = true;
                    break;
                }
            }
            results = [];
        }
        cleanup();
    }
}
function _command_event_ctx(msg_event) {
    if (msg_event.type === "runtime") {
        throw Error(`Unsupported event: ${msg_event.type}`);
    }
    let evt_obj;
    try {
        evt_obj = JSON.parse(msg_event.data);
    }
    catch (_e) {
        throw Error(`Cannot parse: ${msg_event.data}`);
    }
    const evt_kind = evt_obj["kind"][0];
    const evt_data = evt_obj["kind"][evt_kind];
    let evt_cls;
    let props = { cmd_idx: parseInt(evt_obj["index"]) };
    switch (evt_kind) {
        case "started":
            if (!(evt_obj instanceof Object && evt_data["command"])) {
                throw Error("Invalid CommandStarted event: missing 'command'");
            }
            evt_cls = events.CommandStarted;
            props["command"] = evt_data["command"];
        case "finished":
            if (!(evt_obj instanceof Object && Number(evt_data["return_code"]))) {
                throw Error("Invalid CommandFinished event: missing 'return code'");
            }
            evt_cls = events.CommandExecuted;
            props["success"] = parseInt(evt_data["return_code"]) === 0;
            props["message"] = evt_data["message"];
        case "stdout":
            evt_cls = events.CommandStdOut;
            props["output"] = JSON.stringify(evt_data) || "";
        case "stderr":
            evt_cls = events.CommandStdErr;
            props["output"] = JSON.stringify(evt_data) || "";
        default:
            throw Error(`Unsupported runtime event: ${evt_kind}`);
    }
    return new events.CommandEventContext({ evt_cls, props });
}
class ApiConfigProvider extends base_1.BaseAPI {
    constructor(api) {
        let as_this = api;
        super(as_this.configuration, as_this.basePath, as_this.axios);
    }
    base_path() {
        return this.configuration && this.configuration.basePath
            ? this.configuration.basePath
            : "";
    }
    async api_key() {
        let api_key = this.configuration ? this.configuration.apiKey : undefined;
        if (typeof api_key === "string") {
            return api_key;
        }
        return undefined;
    }
}
exports.ApiConfigProvider = ApiConfigProvider;
//# sourceMappingURL=activity.js.map