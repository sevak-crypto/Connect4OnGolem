"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecreaseScoreForUnconfirmedAgreement = exports.LeastExpensiveLinearPayuMS = exports.DummyMS = exports.MarketStrategy = exports.SCORE_TRUSTED = exports.SCORE_REJECTED = exports.SCORE_NEUTRAL = void 0;
const props_1 = require("../props");
const com_1 = require("../props/com");
const utils_1 = require("../utils");
exports.SCORE_NEUTRAL = 0.0;
exports.SCORE_REJECTED = -1.0;
exports.SCORE_TRUSTED = 100.0;
class MarketStrategy {
    async decorate_demand(demand) { }
    async score_offer(offer, history) {
        return exports.SCORE_REJECTED;
    }
}
exports.MarketStrategy = MarketStrategy;
class MarketGeneral {
}
utils_1.applyMixins(MarketGeneral, [MarketStrategy, Object]);
class DummyMS extends MarketGeneral {
    constructor() {
        super(...arguments);
        this.max_for_counter = new Map([
            [com_1.Counter.TIME, parseFloat("0.002")],
            [com_1.Counter.CPU, parseFloat("0.002") * 10],
        ]);
        this.max_fixed = parseFloat("0.05");
    }
    async decorate_demand(demand) {
        demand.ensure(`(${com_1.PRICE_MODEL}=${com_1.PriceModel.LINEAR})`);
        this._activity = new props_1.Activity().from_properties(demand._properties);
    }
    async score_offer(offer, history) {
        const linear = new com_1.ComLinear().from_properties(offer.props());
        if (linear.scheme.value !== com_1.BillingScheme.PAYU) {
            return exports.SCORE_REJECTED;
        }
        if (linear.fixed_price > this.max_fixed)
            return exports.SCORE_REJECTED;
        for (const [counter, price] of Object.entries(linear.price_for)) {
            if (!this.max_for_counter.has(counter))
                return exports.SCORE_REJECTED;
            if (price > this.max_for_counter.get(counter))
                return exports.SCORE_REJECTED;
        }
        return exports.SCORE_NEUTRAL;
    }
}
exports.DummyMS = DummyMS;
class LeastExpensiveLinearPayuMS {
    constructor(expected_time_secs = 60, max_fixed_price, max_price_for) {
        this._expected_time_secs = expected_time_secs;
        if (max_fixed_price)
            this._max_fixed_price = max_fixed_price;
        if (max_price_for)
            this._max_price_for = max_price_for;
    }
    async decorate_demand(demand) {
        demand.ensure(`(${com_1.PRICE_MODEL}=${com_1.PriceModel.LINEAR})`);
    }
    async score_offer(offer, history) {
        const linear = new com_1.ComLinear().from_properties(offer.props());
        utils_1.logger.debug(`Scoring offer ${offer.id()}, parameters: ${JSON.stringify(linear)}`);
        if (linear.scheme.value !== com_1.BillingScheme.PAYU) {
            utils_1.logger.debug(`Rejected offer ${offer.id()}: unsupported scheme '${linear.scheme.value}'`);
            return exports.SCORE_REJECTED;
        }
        const known_time_prices = new Set([com_1.Counter.TIME, com_1.Counter.CPU]);
        for (const counter in linear.price_for) {
            if (!(known_time_prices.has(counter))) {
                utils_1.logger.debug(`Rejected offer ${offer.id()}: unsupported counter '${counter}'`);
                return exports.SCORE_REJECTED;
            }
        }
        if (this._max_fixed_price !== undefined) {
            const fixed_price_cap = this._max_fixed_price;
            if (linear.fixed_price > fixed_price_cap) {
                utils_1.logger.debug(`Rejected offer ${offer.id()}: fixed price higher than fixed price cap ${fixed_price_cap}.`);
                return exports.SCORE_REJECTED;
            }
        }
        if (linear.fixed_price < 0) {
            utils_1.logger.debug(`Rejected offer ${offer.id()}: negative fixed price`);
            return exports.SCORE_REJECTED;
        }
        let expected_price = linear.fixed_price;
        for (const resource of known_time_prices) {
            if (linear.price_for[resource] < 0) {
                utils_1.logger.debug(`Rejected offer ${offer.id()}: negative price for '${resource}'`);
                return exports.SCORE_REJECTED;
            }
            if (this._max_price_for) {
                const max_price = this._max_price_for.get(resource);
                if (max_price !== undefined && linear.price_for[resource] > max_price) {
                    utils_1.logger.debug(`Rejected offer ${offer.id()}: price for '${resource}' higher than price cap ${max_price}`);
                    return exports.SCORE_REJECTED;
                }
            }
            expected_price += linear.price_for[resource] * this._expected_time_secs;
        }
        const score = (exports.SCORE_TRUSTED * 1.0) / (expected_price + 1.01);
        return score;
    }
}
exports.LeastExpensiveLinearPayuMS = LeastExpensiveLinearPayuMS;
class DecreaseScoreForUnconfirmedAgreement {
    constructor(base_strategy, factor) {
        this._base_strategy = base_strategy;
        this._factor = factor;
    }
    async decorate_demand(demand) {
        await this._base_strategy.decorate_demand(demand);
    }
    async score_offer(offer, history) {
        let score = await this._base_strategy.score_offer(offer);
        if (history && history.rejected_last_agreement(offer.issuer()) && score > 0) {
            score *= this._factor;
            utils_1.logger.debug(`Decreasing score for offer ${offer.id()} from '${offer.issuer()}'`);
        }
        return score;
    }
}
exports.DecreaseScoreForUnconfirmedAgreement = DecreaseScoreForUnconfirmedAgreement;
//# sourceMappingURL=strategy.js.map