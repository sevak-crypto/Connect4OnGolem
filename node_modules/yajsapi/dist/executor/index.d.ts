import { MarketDecoration } from "ya-ts-client/dist/ya-payment/src/models";
import { WorkContext, Work } from "./ctx";
import * as events from "./events";
import * as rest from "../rest";
import { OfferProposal } from "../rest/market";
import { Allocation, DebitNote, Invoice } from "../rest/payment";
import { Callable } from "../utils";
export declare const sgx: typeof rest.sgx;
export declare const vm: typeof rest.vm;
import { Task, TaskStatus } from "./task";
import { ComputationHistory, MarketStrategy } from "./strategy";
import { Package } from "../package";
export { Task, TaskStatus };
export declare class NoPaymentAccountError extends Error {
    required_driver: string;
    required_network: string;
    constructor(required_driver: any, required_network: any);
    toString(): string;
}
export declare class _ExecutorConfig {
    max_workers: Number;
    timeout: number;
    get_offers_timeout: number;
    traceback: boolean;
    constructor(max_workers: any, timeout: any);
}
export declare class _BufferItem {
    ts: Date;
    score: Number;
    proposal: OfferProposal;
    constructor(ts: any, score: any, proposal: any);
}
declare type D = "D";
declare type R = "R";
export declare type ExecutorOpts = {
    task_package: Package;
    max_workers?: Number;
    timeout?: Number | String;
    budget: string;
    strategy?: MarketStrategy;
    subnet_tag?: string;
    driver?: string;
    network?: string;
    event_consumer?: Callable<[events.YaEvent], void>;
};
export declare class Executor implements ComputationHistory {
    private _subnet;
    private _driver;
    private _network;
    private _stream_output;
    private _strategy;
    private _api_config;
    private _stack;
    private _task_package;
    private _conf;
    private _expires;
    private _budget_amount;
    private _budget_allocations;
    private _rejecting_providers;
    private _activity_api;
    private _market_api;
    private _payment_api;
    private _wrapped_consumer;
    private _active_computations;
    private _chan_computation_done;
    private _cancellation_token;
    private _worker_cancellation_token;
    private _payment_cancellation_token;
    constructor({ task_package, max_workers, timeout, budget, strategy, subnet_tag, driver, network, event_consumer, }: ExecutorOpts);
    submit(worker: Callable<[WorkContext, AsyncIterable<Task<D, R>>], AsyncGenerator<Work>>, data: Iterable<Task<D, R>>): AsyncGenerator<Task<D, R>>;
    _submit(worker: Callable<[WorkContext, AsyncIterable<Task<D, R>>], AsyncGenerator<Work>>, data: Iterable<Task<D, R>>): AsyncGenerator<Task<D, R>>;
    _create_allocations(): Promise<MarketDecoration>;
    _get_common_payment_platforms(proposal: OfferProposal): string[];
    _get_allocation(item: Invoice | DebitNote): Allocation;
    rejected_last_agreement(provider_id: string): boolean;
    ready(): Promise<Executor>;
    done(this: any): Promise<void>;
}
