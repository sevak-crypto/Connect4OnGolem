/**
 * Yagna Market API
 *  ## Yagna Market The Yagna Market is a core component of the Yagna Network, which enables computational Offers and Demands circulation. The Market is open for all entities willing to buy computations (Demands) or monetize computational resources (Offers). ## Yagna Market API The Yagna Market API is the entry to the Yagna Market through which Requestors and Providers can publish their Demands and Offers respectively, find matching counterparty, conduct negotiations and make an agreement.  This version of Market API conforms with capability level 1 of the <a href=\"https://docs.google.com/document/d/1Zny_vfgWV-hcsKS7P-Kdr3Fb0dwfl-6T_cYKVQ9mkNg\"> Market API specification</a>.  Market API contains two roles: Requestors and Providers which are symmetrical most of the time (excluding agreement phase).
 *
 * The version of the OpenAPI document: 1.6.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../../configuration';
import { RequestArgs, BaseAPI } from '../../base';
import { Agreement } from '../../src/models';
import { AgreementEvent } from '../../src/models';
import { DemandOfferBase } from '../../src/models';
import { Event } from '../../src/models';
import { Offer } from '../../src/models';
import { Proposal } from '../../src/models';
/**
 * ProviderApi - axios parameter creator
 * @export
 */
export declare const ProviderApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another `approveAgreement` call can be raised on the same `agreementId`.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until `Approved` response is received from the `approveAgreement` call.  **Note**: Mutually exclusive with `rejectAgreement`.
     * @summary ApproveAgreement - Approves Agreement proposed by the Reqestor.
     * @param {string} agreementId
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveAgreement: (agreementId: string, appSessionId?: string, timeout?: number, options?: any) => Promise<RequestArgs>;
    /**
     * This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * `AgreementApprovedEvent` - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding `approveAgreement` call returns `Approved`     after this event is emitted.  * `AgreementRejectedEvent` - Indicates that the Provider has called   `rejectAgreement`, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * `AgreementCancelledEvent` - Indicates that the Requestor has called   `cancelAgreement`, which effectively stops the Agreement handshake.  * `AgreementTerminatedEvent` - Indicates that the Agreement has been   terminated by specified party (contains signature).
     * @summary CollectAgreementEvents - Collects events related to an Agreement.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectAgreementEvents: (timeout?: number, afterTimestamp?: string, maxEvents?: number, appSessionId?: string, options?: any) => Promise<RequestArgs>;
    /**
     * This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * `ProposalEvent` - Indicates that there is new Demand Proposal for this Offer. * `ProposalRejectedEvent` - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * `AgreementEvent` - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * `PropertyQueryEvent` - not supported yet.  **Note**: When `collectDemands` is waiting, simultaneous call to `unsubscribeOffer` on the same `subscriptionId` should result in \"Subscription does not exist\" error returned from `collectDemands`.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet.
     * @summary CollectDemands - Reads Market responses to published Offer.
     * @param {string} subscriptionId
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectDemands: (subscriptionId: string, timeout?: number, maxEvents?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to `Draft`. Returns created Proposal id.
     * @summary CounterProposalOffer - Responds with a bespoke Offer to received Demand.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    counterProposalOffer: (subscriptionId: string, proposalId: string, demandOfferBase: DemandOfferBase, options?: any) => Promise<RequestArgs>;
    /**
     *
     * @summary GetAgreement - Fetches agreement with given agreement id.
     * @param {string} agreementId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAgreement: (agreementId: string, options?: any) => Promise<RequestArgs>;
    /**
     *
     * @summary GetOffers - Fetches all active Offers which have been published by the Provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOffers: (options?: any) => Promise<RequestArgs>;
    /**
     *
     * @summary GetProposalDemand - Fetches Proposal (Demand) with given id.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProposalDemand: (subscriptionId: string, proposalId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2.
     * @summary QueryReplyOffers - Handles dynamic property query.
     * @param {string} subscriptionId
     * @param {string} queryId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryReplyOffers: (subscriptionId: string, queryId: string, body: object, options?: any) => Promise<RequestArgs>;
    /**
     * The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with `approveAgreement`.
     * @summary RejectAgreement - Rejects Agreement proposed by the Requestor.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectAgreement: (agreementId: string, requestBody?: {
        [key: string]: object;
    }, options?: any) => Promise<RequestArgs>;
    /**
     * Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal.
     * @summary RejectProposalDemand - Rejects Proposal (Demand).
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectProposalDemand: (subscriptionId: string, proposalId: string, requestBody?: {
        [key: string]: object;
    }, options?: any) => Promise<RequestArgs>;
    /**
     * Offer object can be considered an \"open\" or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \"atomic\" operation, ie. as soon as Subscription is placed, the Offer is published on the market.
     * @summary SubscribeOffer - Publishes Provider capabilities via Offer.
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscribeOffer: (demandOfferBase: DemandOfferBase, options?: any) => Promise<RequestArgs>;
    /**
     * Method to finish/close the Agreement while in `Approved` state.  The other party gets notified about calling party decision to terminate a \"running\" agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification.
     * @summary TerminateAgreement - Terminates approved Agreement.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateAgreement: (agreementId: string, requestBody?: {
        [key: string]: object;
    }, options?: any) => Promise<RequestArgs>;
    /**
     * Stop receiving Proposals.  **Note**: this will terminate all pending `collectDemands` calls on this subscription. This implies, that client code should not `unsubscribeOffer` before it has received all expected/useful inputs from `collectDemands`.
     * @summary UnsubscribeOffer - Stop subscription for previously published Offer.
     * @param {string} subscriptionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsubscribeOffer: (subscriptionId: string, options?: any) => Promise<RequestArgs>;
};
/**
 * ProviderApi - functional programming interface
 * @export
 */
export declare const ProviderApiFp: (configuration?: Configuration) => {
    /**
     * This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another `approveAgreement` call can be raised on the same `agreementId`.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until `Approved` response is received from the `approveAgreement` call.  **Note**: Mutually exclusive with `rejectAgreement`.
     * @summary ApproveAgreement - Approves Agreement proposed by the Reqestor.
     * @param {string} agreementId
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveAgreement(agreementId: string, appSessionId?: string, timeout?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * `AgreementApprovedEvent` - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding `approveAgreement` call returns `Approved`     after this event is emitted.  * `AgreementRejectedEvent` - Indicates that the Provider has called   `rejectAgreement`, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * `AgreementCancelledEvent` - Indicates that the Requestor has called   `cancelAgreement`, which effectively stops the Agreement handshake.  * `AgreementTerminatedEvent` - Indicates that the Agreement has been   terminated by specified party (contains signature).
     * @summary CollectAgreementEvents - Collects events related to an Agreement.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectAgreementEvents(timeout?: number, afterTimestamp?: string, maxEvents?: number, appSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AgreementEvent>>>;
    /**
     * This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * `ProposalEvent` - Indicates that there is new Demand Proposal for this Offer. * `ProposalRejectedEvent` - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * `AgreementEvent` - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * `PropertyQueryEvent` - not supported yet.  **Note**: When `collectDemands` is waiting, simultaneous call to `unsubscribeOffer` on the same `subscriptionId` should result in \"Subscription does not exist\" error returned from `collectDemands`.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet.
     * @summary CollectDemands - Reads Market responses to published Offer.
     * @param {string} subscriptionId
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectDemands(subscriptionId: string, timeout?: number, maxEvents?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>>;
    /**
     * Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to `Draft`. Returns created Proposal id.
     * @summary CounterProposalOffer - Responds with a bespoke Offer to received Demand.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    counterProposalOffer(subscriptionId: string, proposalId: string, demandOfferBase: DemandOfferBase, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     *
     * @summary GetAgreement - Fetches agreement with given agreement id.
     * @param {string} agreementId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAgreement(agreementId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agreement>>;
    /**
     *
     * @summary GetOffers - Fetches all active Offers which have been published by the Provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOffers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Offer>>>;
    /**
     *
     * @summary GetProposalDemand - Fetches Proposal (Demand) with given id.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProposalDemand(subscriptionId: string, proposalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proposal>>;
    /**
     * Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2.
     * @summary QueryReplyOffers - Handles dynamic property query.
     * @param {string} subscriptionId
     * @param {string} queryId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryReplyOffers(subscriptionId: string, queryId: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with `approveAgreement`.
     * @summary RejectAgreement - Rejects Agreement proposed by the Requestor.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectAgreement(agreementId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal.
     * @summary RejectProposalDemand - Rejects Proposal (Demand).
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectProposalDemand(subscriptionId: string, proposalId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Offer object can be considered an \"open\" or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \"atomic\" operation, ie. as soon as Subscription is placed, the Offer is published on the market.
     * @summary SubscribeOffer - Publishes Provider capabilities via Offer.
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscribeOffer(demandOfferBase: DemandOfferBase, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     * Method to finish/close the Agreement while in `Approved` state.  The other party gets notified about calling party decision to terminate a \"running\" agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification.
     * @summary TerminateAgreement - Terminates approved Agreement.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateAgreement(agreementId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Stop receiving Proposals.  **Note**: this will terminate all pending `collectDemands` calls on this subscription. This implies, that client code should not `unsubscribeOffer` before it has received all expected/useful inputs from `collectDemands`.
     * @summary UnsubscribeOffer - Stop subscription for previously published Offer.
     * @param {string} subscriptionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsubscribeOffer(subscriptionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * ProviderApi - factory interface
 * @export
 */
export declare const ProviderApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another `approveAgreement` call can be raised on the same `agreementId`.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until `Approved` response is received from the `approveAgreement` call.  **Note**: Mutually exclusive with `rejectAgreement`.
     * @summary ApproveAgreement - Approves Agreement proposed by the Reqestor.
     * @param {string} agreementId
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveAgreement(agreementId: string, appSessionId?: string, timeout?: number, options?: any): AxiosPromise<void>;
    /**
     * This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * `AgreementApprovedEvent` - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding `approveAgreement` call returns `Approved`     after this event is emitted.  * `AgreementRejectedEvent` - Indicates that the Provider has called   `rejectAgreement`, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * `AgreementCancelledEvent` - Indicates that the Requestor has called   `cancelAgreement`, which effectively stops the Agreement handshake.  * `AgreementTerminatedEvent` - Indicates that the Agreement has been   terminated by specified party (contains signature).
     * @summary CollectAgreementEvents - Collects events related to an Agreement.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectAgreementEvents(timeout?: number, afterTimestamp?: string, maxEvents?: number, appSessionId?: string, options?: any): AxiosPromise<Array<AgreementEvent>>;
    /**
     * This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * `ProposalEvent` - Indicates that there is new Demand Proposal for this Offer. * `ProposalRejectedEvent` - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * `AgreementEvent` - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * `PropertyQueryEvent` - not supported yet.  **Note**: When `collectDemands` is waiting, simultaneous call to `unsubscribeOffer` on the same `subscriptionId` should result in \"Subscription does not exist\" error returned from `collectDemands`.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet.
     * @summary CollectDemands - Reads Market responses to published Offer.
     * @param {string} subscriptionId
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectDemands(subscriptionId: string, timeout?: number, maxEvents?: number, options?: any): AxiosPromise<Array<Event>>;
    /**
     * Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to `Draft`. Returns created Proposal id.
     * @summary CounterProposalOffer - Responds with a bespoke Offer to received Demand.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    counterProposalOffer(subscriptionId: string, proposalId: string, demandOfferBase: DemandOfferBase, options?: any): AxiosPromise<string>;
    /**
     *
     * @summary GetAgreement - Fetches agreement with given agreement id.
     * @param {string} agreementId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAgreement(agreementId: string, options?: any): AxiosPromise<Agreement>;
    /**
     *
     * @summary GetOffers - Fetches all active Offers which have been published by the Provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOffers(options?: any): AxiosPromise<Array<Offer>>;
    /**
     *
     * @summary GetProposalDemand - Fetches Proposal (Demand) with given id.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProposalDemand(subscriptionId: string, proposalId: string, options?: any): AxiosPromise<Proposal>;
    /**
     * Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2.
     * @summary QueryReplyOffers - Handles dynamic property query.
     * @param {string} subscriptionId
     * @param {string} queryId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryReplyOffers(subscriptionId: string, queryId: string, body: object, options?: any): AxiosPromise<void>;
    /**
     * The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with `approveAgreement`.
     * @summary RejectAgreement - Rejects Agreement proposed by the Requestor.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectAgreement(agreementId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): AxiosPromise<void>;
    /**
     * Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal.
     * @summary RejectProposalDemand - Rejects Proposal (Demand).
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectProposalDemand(subscriptionId: string, proposalId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): AxiosPromise<void>;
    /**
     * Offer object can be considered an \"open\" or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \"atomic\" operation, ie. as soon as Subscription is placed, the Offer is published on the market.
     * @summary SubscribeOffer - Publishes Provider capabilities via Offer.
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscribeOffer(demandOfferBase: DemandOfferBase, options?: any): AxiosPromise<string>;
    /**
     * Method to finish/close the Agreement while in `Approved` state.  The other party gets notified about calling party decision to terminate a \"running\" agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification.
     * @summary TerminateAgreement - Terminates approved Agreement.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateAgreement(agreementId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): AxiosPromise<void>;
    /**
     * Stop receiving Proposals.  **Note**: this will terminate all pending `collectDemands` calls on this subscription. This implies, that client code should not `unsubscribeOffer` before it has received all expected/useful inputs from `collectDemands`.
     * @summary UnsubscribeOffer - Stop subscription for previously published Offer.
     * @param {string} subscriptionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsubscribeOffer(subscriptionId: string, options?: any): AxiosPromise<void>;
};
/**
 * ProviderApi - interface
 * @export
 * @interface ProviderApi
 */
export interface ProviderApiInterface {
    /**
     * This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another `approveAgreement` call can be raised on the same `agreementId`.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until `Approved` response is received from the `approveAgreement` call.  **Note**: Mutually exclusive with `rejectAgreement`.
     * @summary ApproveAgreement - Approves Agreement proposed by the Reqestor.
     * @param {string} agreementId
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    approveAgreement(agreementId: string, appSessionId?: string, timeout?: number, options?: any): AxiosPromise<void>;
    /**
     * This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * `AgreementApprovedEvent` - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding `approveAgreement` call returns `Approved`     after this event is emitted.  * `AgreementRejectedEvent` - Indicates that the Provider has called   `rejectAgreement`, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * `AgreementCancelledEvent` - Indicates that the Requestor has called   `cancelAgreement`, which effectively stops the Agreement handshake.  * `AgreementTerminatedEvent` - Indicates that the Agreement has been   terminated by specified party (contains signature).
     * @summary CollectAgreementEvents - Collects events related to an Agreement.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    collectAgreementEvents(timeout?: number, afterTimestamp?: string, maxEvents?: number, appSessionId?: string, options?: any): AxiosPromise<Array<AgreementEvent>>;
    /**
     * This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * `ProposalEvent` - Indicates that there is new Demand Proposal for this Offer. * `ProposalRejectedEvent` - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * `AgreementEvent` - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * `PropertyQueryEvent` - not supported yet.  **Note**: When `collectDemands` is waiting, simultaneous call to `unsubscribeOffer` on the same `subscriptionId` should result in \"Subscription does not exist\" error returned from `collectDemands`.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet.
     * @summary CollectDemands - Reads Market responses to published Offer.
     * @param {string} subscriptionId
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    collectDemands(subscriptionId: string, timeout?: number, maxEvents?: number, options?: any): AxiosPromise<Array<Event>>;
    /**
     * Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to `Draft`. Returns created Proposal id.
     * @summary CounterProposalOffer - Responds with a bespoke Offer to received Demand.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    counterProposalOffer(subscriptionId: string, proposalId: string, demandOfferBase: DemandOfferBase, options?: any): AxiosPromise<string>;
    /**
     *
     * @summary GetAgreement - Fetches agreement with given agreement id.
     * @param {string} agreementId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    getAgreement(agreementId: string, options?: any): AxiosPromise<Agreement>;
    /**
     *
     * @summary GetOffers - Fetches all active Offers which have been published by the Provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    getOffers(options?: any): AxiosPromise<Array<Offer>>;
    /**
     *
     * @summary GetProposalDemand - Fetches Proposal (Demand) with given id.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    getProposalDemand(subscriptionId: string, proposalId: string, options?: any): AxiosPromise<Proposal>;
    /**
     * Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2.
     * @summary QueryReplyOffers - Handles dynamic property query.
     * @param {string} subscriptionId
     * @param {string} queryId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    queryReplyOffers(subscriptionId: string, queryId: string, body: object, options?: any): AxiosPromise<void>;
    /**
     * The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with `approveAgreement`.
     * @summary RejectAgreement - Rejects Agreement proposed by the Requestor.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    rejectAgreement(agreementId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): AxiosPromise<void>;
    /**
     * Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal.
     * @summary RejectProposalDemand - Rejects Proposal (Demand).
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    rejectProposalDemand(subscriptionId: string, proposalId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): AxiosPromise<void>;
    /**
     * Offer object can be considered an \"open\" or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \"atomic\" operation, ie. as soon as Subscription is placed, the Offer is published on the market.
     * @summary SubscribeOffer - Publishes Provider capabilities via Offer.
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    subscribeOffer(demandOfferBase: DemandOfferBase, options?: any): AxiosPromise<string>;
    /**
     * Method to finish/close the Agreement while in `Approved` state.  The other party gets notified about calling party decision to terminate a \"running\" agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification.
     * @summary TerminateAgreement - Terminates approved Agreement.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    terminateAgreement(agreementId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): AxiosPromise<void>;
    /**
     * Stop receiving Proposals.  **Note**: this will terminate all pending `collectDemands` calls on this subscription. This implies, that client code should not `unsubscribeOffer` before it has received all expected/useful inputs from `collectDemands`.
     * @summary UnsubscribeOffer - Stop subscription for previously published Offer.
     * @param {string} subscriptionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    unsubscribeOffer(subscriptionId: string, options?: any): AxiosPromise<void>;
}
/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
export declare class ProviderApi extends BaseAPI implements ProviderApiInterface {
    /**
     * This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another `approveAgreement` call can be raised on the same `agreementId`.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until `Approved` response is received from the `approveAgreement` call.  **Note**: Mutually exclusive with `rejectAgreement`.
     * @summary ApproveAgreement - Approves Agreement proposed by the Reqestor.
     * @param {string} agreementId
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    approveAgreement(agreementId: string, appSessionId?: string, timeout?: number, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * `AgreementApprovedEvent` - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding `approveAgreement` call returns `Approved`     after this event is emitted.  * `AgreementRejectedEvent` - Indicates that the Provider has called   `rejectAgreement`, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * `AgreementCancelledEvent` - Indicates that the Requestor has called   `cancelAgreement`, which effectively stops the Agreement handshake.  * `AgreementTerminatedEvent` - Indicates that the Agreement has been   terminated by specified party (contains signature).
     * @summary CollectAgreementEvents - Collects events related to an Agreement.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    collectAgreementEvents(timeout?: number, afterTimestamp?: string, maxEvents?: number, appSessionId?: string, options?: any): Promise<import("axios").AxiosResponse<AgreementEvent[]>>;
    /**
     * This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * `ProposalEvent` - Indicates that there is new Demand Proposal for this Offer. * `ProposalRejectedEvent` - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * `AgreementEvent` - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * `PropertyQueryEvent` - not supported yet.  **Note**: When `collectDemands` is waiting, simultaneous call to `unsubscribeOffer` on the same `subscriptionId` should result in \"Subscription does not exist\" error returned from `collectDemands`.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet.
     * @summary CollectDemands - Reads Market responses to published Offer.
     * @param {string} subscriptionId
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    collectDemands(subscriptionId: string, timeout?: number, maxEvents?: number, options?: any): Promise<import("axios").AxiosResponse<Event[]>>;
    /**
     * Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to `Draft`. Returns created Proposal id.
     * @summary CounterProposalOffer - Responds with a bespoke Offer to received Demand.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    counterProposalOffer(subscriptionId: string, proposalId: string, demandOfferBase: DemandOfferBase, options?: any): Promise<import("axios").AxiosResponse<string>>;
    /**
     *
     * @summary GetAgreement - Fetches agreement with given agreement id.
     * @param {string} agreementId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getAgreement(agreementId: string, options?: any): Promise<import("axios").AxiosResponse<Agreement>>;
    /**
     *
     * @summary GetOffers - Fetches all active Offers which have been published by the Provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getOffers(options?: any): Promise<import("axios").AxiosResponse<Offer[]>>;
    /**
     *
     * @summary GetProposalDemand - Fetches Proposal (Demand) with given id.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getProposalDemand(subscriptionId: string, proposalId: string, options?: any): Promise<import("axios").AxiosResponse<Proposal>>;
    /**
     * Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2.
     * @summary QueryReplyOffers - Handles dynamic property query.
     * @param {string} subscriptionId
     * @param {string} queryId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    queryReplyOffers(subscriptionId: string, queryId: string, body: object, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with `approveAgreement`.
     * @summary RejectAgreement - Rejects Agreement proposed by the Requestor.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    rejectAgreement(agreementId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal.
     * @summary RejectProposalDemand - Rejects Proposal (Demand).
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    rejectProposalDemand(subscriptionId: string, proposalId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Offer object can be considered an \"open\" or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \"atomic\" operation, ie. as soon as Subscription is placed, the Offer is published on the market.
     * @summary SubscribeOffer - Publishes Provider capabilities via Offer.
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    subscribeOffer(demandOfferBase: DemandOfferBase, options?: any): Promise<import("axios").AxiosResponse<string>>;
    /**
     * Method to finish/close the Agreement while in `Approved` state.  The other party gets notified about calling party decision to terminate a \"running\" agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification.
     * @summary TerminateAgreement - Terminates approved Agreement.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    terminateAgreement(agreementId: string, requestBody?: {
        [key: string]: object;
    }, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Stop receiving Proposals.  **Note**: this will terminate all pending `collectDemands` calls on this subscription. This implies, that client code should not `unsubscribeOffer` before it has received all expected/useful inputs from `collectDemands`.
     * @summary UnsubscribeOffer - Stop subscription for previously published Offer.
     * @param {string} subscriptionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    unsubscribeOffer(subscriptionId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
