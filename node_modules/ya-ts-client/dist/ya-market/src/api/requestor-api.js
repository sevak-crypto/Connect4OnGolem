"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Yagna Market API
 *  ## Yagna Market The Yagna Market is a core component of the Yagna Network, which enables computational Offers and Demands circulation. The Market is open for all entities willing to buy computations (Demands) or monetize computational resources (Offers). ## Yagna Market API The Yagna Market API is the entry to the Yagna Market through which Requestors and Providers can publish their Demands and Offers respectively, find matching counterparty, conduct negotiations and make an agreement.  This version of Market API conforms with capability level 1 of the <a href=\"https://docs.google.com/document/d/1Zny_vfgWV-hcsKS7P-Kdr3Fb0dwfl-6T_cYKVQ9mkNg\"> Market API specification</a>.  Market API contains two roles: Requestors and Providers which are symmetrical most of the time (excluding agreement phase).
 *
 * The version of the OpenAPI document: 1.6.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestorApi = exports.RequestorApiFactory = exports.RequestorApiFp = exports.RequestorApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("../../base");
/**
 * RequestorApi - axios parameter creator
 * @export
 */
exports.RequestorApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting `approveAgreement` on Provider side to return with `Cancelled` response.   - the awaiting `waitForApproval` local call to return with `Cancelled` response.
         * @summary CancelAgreement - Cancels Agreement.
         * @param {string} agreementId
         * @param {{ [key: string]: object; }} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelAgreement: (agreementId, requestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agreementId' is not null or undefined
            if (agreementId === null || agreementId === undefined) {
                throw new base_1.RequiredError('agreementId', 'Required parameter agreementId was null or undefined when calling cancelAgreement.');
            }
            const localVarPath = `/agreements/{agreementId}/cancel`
                .replace(`{${"agreementId"}}`, encodeURIComponent(String(agreementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof requestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(requestBody !== undefined ? requestBody : {})
                : (requestBody || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * `AgreementApprovedEvent` - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding `approveAgreement` call returns `Approved`     after this event is emitted.  * `AgreementRejectedEvent` - Indicates that the Provider has called   `rejectAgreement`, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * `AgreementCancelledEvent` - Indicates that the Requestor has called   `cancelAgreement`, which effectively stops the Agreement handshake.  * `AgreementTerminatedEvent` - Indicates that the Agreement has been   terminated by specified party (contains signature).
         * @summary CollectAgreementEvents - Collects events related to an Agreement.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectAgreementEvents: (timeout, afterTimestamp, maxEvents, appSessionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/agreementEvents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxEvents !== undefined) {
                localVarQueryParameter['maxEvents'] = maxEvents;
            }
            if (appSessionId !== undefined) {
                localVarQueryParameter['appSessionId'] = appSessionId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * `ProposalEvent` - Indicates that there is new Offer Proposal for this Demand. * `ProposalRejectedEvent` - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * `PropertyQueryEvent` - not supported yet.  **Note**: When `collectOffers` is waiting, simultaneous call to `unsubscribeDemand` on the same `subscriptionId` should result in \"Subscription does not exist\" error returned from `collectOffers`.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet.
         * @summary CollectOffers - Reads Market responses to published Demand.
         * @param {string} subscriptionId
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectOffers: (subscriptionId, timeout, maxEvents, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new base_1.RequiredError('subscriptionId', 'Required parameter subscriptionId was null or undefined when calling collectOffers.');
            }
            const localVarPath = `/demands/{subscriptionId}/events`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (maxEvents !== undefined) {
                localVarQueryParameter['maxEvents'] = maxEvents;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Signs self-created Agreement and sends it to the Provider.  This call should immediately follow `createAgreement`.
         * @summary ConfirmAgreement - Sends Agreement proposal to the Provider.
         * @param {string} agreementId
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmAgreement: (agreementId, appSessionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agreementId' is not null or undefined
            if (agreementId === null || agreementId === undefined) {
                throw new base_1.RequiredError('agreementId', 'Required parameter agreementId was null or undefined when calling confirmAgreement.');
            }
            const localVarPath = `/agreements/{agreementId}/confirm`
                .replace(`{${"agreementId"}}`, encodeURIComponent(String(agreementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (appSessionId !== undefined) {
                localVarQueryParameter['appSessionId'] = appSessionId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to `Draft`. Returns created Proposal id.
         * @summary CounterProposalDemand - Responds with a bespoke Demand to received Offer.
         * @param {string} subscriptionId
         * @param {string} proposalId
         * @param {DemandOfferBase} demandOfferBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        counterProposalDemand: (subscriptionId, proposalId, demandOfferBase, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new base_1.RequiredError('subscriptionId', 'Required parameter subscriptionId was null or undefined when calling counterProposalDemand.');
            }
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling counterProposalDemand.');
            }
            // verify required parameter 'demandOfferBase' is not null or undefined
            if (demandOfferBase === null || demandOfferBase === undefined) {
                throw new base_1.RequiredError('demandOfferBase', 'Required parameter demandOfferBase was null or undefined when calling counterProposalDemand.');
            }
            const localVarPath = `/demands/{subscriptionId}/proposals/{proposalId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof demandOfferBase !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(demandOfferBase !== undefined ? demandOfferBase : {})
                : (demandOfferBase || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in `Proposal` state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to `createAgreement` shall immediately be followed by a `confirmAgreement` and `waitForApproval` call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to `Approved` state.
         * @summary CreateAgreement - Creates Agreement from selected Proposal.
         * @param {AgreementProposal} agreementProposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgreement: (agreementProposal, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agreementProposal' is not null or undefined
            if (agreementProposal === null || agreementProposal === undefined) {
                throw new base_1.RequiredError('agreementProposal', 'Required parameter agreementProposal was null or undefined when calling createAgreement.');
            }
            const localVarPath = `/agreements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof agreementProposal !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(agreementProposal !== undefined ? agreementProposal : {})
                : (agreementProposal || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary GetAgreement - Fetches agreement with given agreement id.
         * @param {string} agreementId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgreement: (agreementId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agreementId' is not null or undefined
            if (agreementId === null || agreementId === undefined) {
                throw new base_1.RequiredError('agreementId', 'Required parameter agreementId was null or undefined when calling getAgreement.');
            }
            const localVarPath = `/agreements/{agreementId}`
                .replace(`{${"agreementId"}}`, encodeURIComponent(String(agreementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary GetDemands - Fetches all active Demands which have been published by the Requestor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemands: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/demands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary GetProposalOffer - Fetches Proposal (Offer) with given id.
         * @param {string} subscriptionId
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProposalOffer: (subscriptionId, proposalId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new base_1.RequiredError('subscriptionId', 'Required parameter subscriptionId was null or undefined when calling getProposalOffer.');
            }
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling getProposalOffer.');
            }
            const localVarPath = `/demands/{subscriptionId}/proposals/{proposalId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2.
         * @summary QueryReplyDemands - Handles dynamic property query.
         * @param {string} subscriptionId
         * @param {string} queryId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryReplyDemands: (subscriptionId, queryId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new base_1.RequiredError('subscriptionId', 'Required parameter subscriptionId was null or undefined when calling queryReplyDemands.');
            }
            // verify required parameter 'queryId' is not null or undefined
            if (queryId === null || queryId === undefined) {
                throw new base_1.RequiredError('queryId', 'Required parameter queryId was null or undefined when calling queryReplyDemands.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling queryReplyDemands.');
            }
            const localVarPath = `/demands/{subscriptionId}/propertyQuery/{queryId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"queryId"}}`, encodeURIComponent(String(queryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal.
         * @summary RejectProposalOffer - Rejects Proposal (Offer).
         * @param {string} subscriptionId
         * @param {string} proposalId
         * @param {{ [key: string]: object; }} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectProposalOffer: (subscriptionId, proposalId, requestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new base_1.RequiredError('subscriptionId', 'Required parameter subscriptionId was null or undefined when calling rejectProposalOffer.');
            }
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling rejectProposalOffer.');
            }
            const localVarPath = `/demands/{subscriptionId}/proposals/{proposalId}/reject`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof requestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(requestBody !== undefined ? requestBody : {})
                : (requestBody || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Demand object can be considered an \"open\" or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \"atomic\" operation, ie. as soon as Subscription is placed, the Demand is published on the market.
         * @summary SubscribeDemand - Publishes Requestor capabilities via Demand.
         * @param {DemandOfferBase} demandOfferBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeDemand: (demandOfferBase, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'demandOfferBase' is not null or undefined
            if (demandOfferBase === null || demandOfferBase === undefined) {
                throw new base_1.RequiredError('demandOfferBase', 'Required parameter demandOfferBase was null or undefined when calling subscribeDemand.');
            }
            const localVarPath = `/demands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof demandOfferBase !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(demandOfferBase !== undefined ? demandOfferBase : {})
                : (demandOfferBase || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Method to finish/close the Agreement while in `Approved` state.  The other party gets notified about calling party decision to terminate a \"running\" agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification.
         * @summary TerminateAgreement - Terminates approved Agreement.
         * @param {string} agreementId
         * @param {{ [key: string]: object; }} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateAgreement: (agreementId, requestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agreementId' is not null or undefined
            if (agreementId === null || agreementId === undefined) {
                throw new base_1.RequiredError('agreementId', 'Required parameter agreementId was null or undefined when calling terminateAgreement.');
            }
            const localVarPath = `/agreements/{agreementId}/terminate`
                .replace(`{${"agreementId"}}`, encodeURIComponent(String(agreementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof requestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(requestBody !== undefined ? requestBody : {})
                : (requestBody || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Stop receiving Proposals.  **Note**: this will terminate all pending `collectOffers` calls on this subscription. This implies, that client code should not `unsubscribeDemand` before it has received all expected/useful inputs from `collectOffers`.
         * @summary UnsubscribeDemand - Stop subscription for previously published Demand.
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeDemand: (subscriptionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new base_1.RequiredError('subscriptionId', 'Required parameter subscriptionId was null or undefined when calling unsubscribeDemand.');
            }
            const localVarPath = `/demands/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another `waitForApproval` call can be raised on the same Agreement Id.
         * @summary WaitForApproval - Waits for Agreement approval by the Provider.
         * @param {string} agreementId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForApproval: (agreementId, timeout, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agreementId' is not null or undefined
            if (agreementId === null || agreementId === undefined) {
                throw new base_1.RequiredError('agreementId', 'Required parameter agreementId was null or undefined when calling waitForApproval.');
            }
            const localVarPath = `/agreements/{agreementId}/wait`
                .replace(`{${"agreementId"}}`, encodeURIComponent(String(agreementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * RequestorApi - functional programming interface
 * @export
 */
exports.RequestorApiFp = function (configuration) {
    return {
        /**
         * It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting `approveAgreement` on Provider side to return with `Cancelled` response.   - the awaiting `waitForApproval` local call to return with `Cancelled` response.
         * @summary CancelAgreement - Cancels Agreement.
         * @param {string} agreementId
         * @param {{ [key: string]: object; }} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelAgreement(agreementId, requestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).cancelAgreement(agreementId, requestBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * `AgreementApprovedEvent` - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding `approveAgreement` call returns `Approved`     after this event is emitted.  * `AgreementRejectedEvent` - Indicates that the Provider has called   `rejectAgreement`, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * `AgreementCancelledEvent` - Indicates that the Requestor has called   `cancelAgreement`, which effectively stops the Agreement handshake.  * `AgreementTerminatedEvent` - Indicates that the Agreement has been   terminated by specified party (contains signature).
         * @summary CollectAgreementEvents - Collects events related to an Agreement.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectAgreementEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).collectAgreementEvents(timeout, afterTimestamp, maxEvents, appSessionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * `ProposalEvent` - Indicates that there is new Offer Proposal for this Demand. * `ProposalRejectedEvent` - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * `PropertyQueryEvent` - not supported yet.  **Note**: When `collectOffers` is waiting, simultaneous call to `unsubscribeDemand` on the same `subscriptionId` should result in \"Subscription does not exist\" error returned from `collectOffers`.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet.
         * @summary CollectOffers - Reads Market responses to published Demand.
         * @param {string} subscriptionId
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectOffers(subscriptionId, timeout, maxEvents, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).collectOffers(subscriptionId, timeout, maxEvents, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Signs self-created Agreement and sends it to the Provider.  This call should immediately follow `createAgreement`.
         * @summary ConfirmAgreement - Sends Agreement proposal to the Provider.
         * @param {string} agreementId
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmAgreement(agreementId, appSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).confirmAgreement(agreementId, appSessionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to `Draft`. Returns created Proposal id.
         * @summary CounterProposalDemand - Responds with a bespoke Demand to received Offer.
         * @param {string} subscriptionId
         * @param {string} proposalId
         * @param {DemandOfferBase} demandOfferBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        counterProposalDemand(subscriptionId, proposalId, demandOfferBase, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).counterProposalDemand(subscriptionId, proposalId, demandOfferBase, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in `Proposal` state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to `createAgreement` shall immediately be followed by a `confirmAgreement` and `waitForApproval` call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to `Approved` state.
         * @summary CreateAgreement - Creates Agreement from selected Proposal.
         * @param {AgreementProposal} agreementProposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgreement(agreementProposal, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).createAgreement(agreementProposal, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary GetAgreement - Fetches agreement with given agreement id.
         * @param {string} agreementId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgreement(agreementId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getAgreement(agreementId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary GetDemands - Fetches all active Demands which have been published by the Requestor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemands(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getDemands(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary GetProposalOffer - Fetches Proposal (Offer) with given id.
         * @param {string} subscriptionId
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProposalOffer(subscriptionId, proposalId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getProposalOffer(subscriptionId, proposalId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2.
         * @summary QueryReplyDemands - Handles dynamic property query.
         * @param {string} subscriptionId
         * @param {string} queryId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryReplyDemands(subscriptionId, queryId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).queryReplyDemands(subscriptionId, queryId, body, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal.
         * @summary RejectProposalOffer - Rejects Proposal (Offer).
         * @param {string} subscriptionId
         * @param {string} proposalId
         * @param {{ [key: string]: object; }} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectProposalOffer(subscriptionId, proposalId, requestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).rejectProposalOffer(subscriptionId, proposalId, requestBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Demand object can be considered an \"open\" or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \"atomic\" operation, ie. as soon as Subscription is placed, the Demand is published on the market.
         * @summary SubscribeDemand - Publishes Requestor capabilities via Demand.
         * @param {DemandOfferBase} demandOfferBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeDemand(demandOfferBase, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).subscribeDemand(demandOfferBase, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Method to finish/close the Agreement while in `Approved` state.  The other party gets notified about calling party decision to terminate a \"running\" agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification.
         * @summary TerminateAgreement - Terminates approved Agreement.
         * @param {string} agreementId
         * @param {{ [key: string]: object; }} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateAgreement(agreementId, requestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).terminateAgreement(agreementId, requestBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Stop receiving Proposals.  **Note**: this will terminate all pending `collectOffers` calls on this subscription. This implies, that client code should not `unsubscribeDemand` before it has received all expected/useful inputs from `collectOffers`.
         * @summary UnsubscribeDemand - Stop subscription for previously published Demand.
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeDemand(subscriptionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).unsubscribeDemand(subscriptionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another `waitForApproval` call can be raised on the same Agreement Id.
         * @summary WaitForApproval - Waits for Agreement approval by the Provider.
         * @param {string} agreementId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForApproval(agreementId, timeout, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).waitForApproval(agreementId, timeout, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * RequestorApi - factory interface
 * @export
 */
exports.RequestorApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting `approveAgreement` on Provider side to return with `Cancelled` response.   - the awaiting `waitForApproval` local call to return with `Cancelled` response.
         * @summary CancelAgreement - Cancels Agreement.
         * @param {string} agreementId
         * @param {{ [key: string]: object; }} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelAgreement(agreementId, requestBody, options) {
            return exports.RequestorApiFp(configuration).cancelAgreement(agreementId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * `AgreementApprovedEvent` - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding `approveAgreement` call returns `Approved`     after this event is emitted.  * `AgreementRejectedEvent` - Indicates that the Provider has called   `rejectAgreement`, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * `AgreementCancelledEvent` - Indicates that the Requestor has called   `cancelAgreement`, which effectively stops the Agreement handshake.  * `AgreementTerminatedEvent` - Indicates that the Agreement has been   terminated by specified party (contains signature).
         * @summary CollectAgreementEvents - Collects events related to an Agreement.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectAgreementEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return exports.RequestorApiFp(configuration).collectAgreementEvents(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * `ProposalEvent` - Indicates that there is new Offer Proposal for this Demand. * `ProposalRejectedEvent` - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * `PropertyQueryEvent` - not supported yet.  **Note**: When `collectOffers` is waiting, simultaneous call to `unsubscribeDemand` on the same `subscriptionId` should result in \"Subscription does not exist\" error returned from `collectOffers`.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet.
         * @summary CollectOffers - Reads Market responses to published Demand.
         * @param {string} subscriptionId
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectOffers(subscriptionId, timeout, maxEvents, options) {
            return exports.RequestorApiFp(configuration).collectOffers(subscriptionId, timeout, maxEvents, options).then((request) => request(axios, basePath));
        },
        /**
         * Signs self-created Agreement and sends it to the Provider.  This call should immediately follow `createAgreement`.
         * @summary ConfirmAgreement - Sends Agreement proposal to the Provider.
         * @param {string} agreementId
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmAgreement(agreementId, appSessionId, options) {
            return exports.RequestorApiFp(configuration).confirmAgreement(agreementId, appSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to `Draft`. Returns created Proposal id.
         * @summary CounterProposalDemand - Responds with a bespoke Demand to received Offer.
         * @param {string} subscriptionId
         * @param {string} proposalId
         * @param {DemandOfferBase} demandOfferBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        counterProposalDemand(subscriptionId, proposalId, demandOfferBase, options) {
            return exports.RequestorApiFp(configuration).counterProposalDemand(subscriptionId, proposalId, demandOfferBase, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in `Proposal` state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to `createAgreement` shall immediately be followed by a `confirmAgreement` and `waitForApproval` call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to `Approved` state.
         * @summary CreateAgreement - Creates Agreement from selected Proposal.
         * @param {AgreementProposal} agreementProposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgreement(agreementProposal, options) {
            return exports.RequestorApiFp(configuration).createAgreement(agreementProposal, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GetAgreement - Fetches agreement with given agreement id.
         * @param {string} agreementId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgreement(agreementId, options) {
            return exports.RequestorApiFp(configuration).getAgreement(agreementId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GetDemands - Fetches all active Demands which have been published by the Requestor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemands(options) {
            return exports.RequestorApiFp(configuration).getDemands(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GetProposalOffer - Fetches Proposal (Offer) with given id.
         * @param {string} subscriptionId
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProposalOffer(subscriptionId, proposalId, options) {
            return exports.RequestorApiFp(configuration).getProposalOffer(subscriptionId, proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2.
         * @summary QueryReplyDemands - Handles dynamic property query.
         * @param {string} subscriptionId
         * @param {string} queryId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryReplyDemands(subscriptionId, queryId, body, options) {
            return exports.RequestorApiFp(configuration).queryReplyDemands(subscriptionId, queryId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal.
         * @summary RejectProposalOffer - Rejects Proposal (Offer).
         * @param {string} subscriptionId
         * @param {string} proposalId
         * @param {{ [key: string]: object; }} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectProposalOffer(subscriptionId, proposalId, requestBody, options) {
            return exports.RequestorApiFp(configuration).rejectProposalOffer(subscriptionId, proposalId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Demand object can be considered an \"open\" or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \"atomic\" operation, ie. as soon as Subscription is placed, the Demand is published on the market.
         * @summary SubscribeDemand - Publishes Requestor capabilities via Demand.
         * @param {DemandOfferBase} demandOfferBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeDemand(demandOfferBase, options) {
            return exports.RequestorApiFp(configuration).subscribeDemand(demandOfferBase, options).then((request) => request(axios, basePath));
        },
        /**
         * Method to finish/close the Agreement while in `Approved` state.  The other party gets notified about calling party decision to terminate a \"running\" agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification.
         * @summary TerminateAgreement - Terminates approved Agreement.
         * @param {string} agreementId
         * @param {{ [key: string]: object; }} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateAgreement(agreementId, requestBody, options) {
            return exports.RequestorApiFp(configuration).terminateAgreement(agreementId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop receiving Proposals.  **Note**: this will terminate all pending `collectOffers` calls on this subscription. This implies, that client code should not `unsubscribeDemand` before it has received all expected/useful inputs from `collectOffers`.
         * @summary UnsubscribeDemand - Stop subscription for previously published Demand.
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeDemand(subscriptionId, options) {
            return exports.RequestorApiFp(configuration).unsubscribeDemand(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another `waitForApproval` call can be raised on the same Agreement Id.
         * @summary WaitForApproval - Waits for Agreement approval by the Provider.
         * @param {string} agreementId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForApproval(agreementId, timeout, options) {
            return exports.RequestorApiFp(configuration).waitForApproval(agreementId, timeout, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RequestorApi - object-oriented interface
 * @export
 * @class RequestorApi
 * @extends {BaseAPI}
 */
class RequestorApi extends base_1.BaseAPI {
    /**
     * It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting `approveAgreement` on Provider side to return with `Cancelled` response.   - the awaiting `waitForApproval` local call to return with `Cancelled` response.
     * @summary CancelAgreement - Cancels Agreement.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    cancelAgreement(agreementId, requestBody, options) {
        return exports.RequestorApiFp(this.configuration).cancelAgreement(agreementId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * `AgreementApprovedEvent` - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding `approveAgreement` call returns `Approved`     after this event is emitted.  * `AgreementRejectedEvent` - Indicates that the Provider has called   `rejectAgreement`, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * `AgreementCancelledEvent` - Indicates that the Requestor has called   `cancelAgreement`, which effectively stops the Agreement handshake.  * `AgreementTerminatedEvent` - Indicates that the Agreement has been   terminated by specified party (contains signature).
     * @summary CollectAgreementEvents - Collects events related to an Agreement.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    collectAgreementEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
        return exports.RequestorApiFp(this.configuration).collectAgreementEvents(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * `ProposalEvent` - Indicates that there is new Offer Proposal for this Demand. * `ProposalRejectedEvent` - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * `PropertyQueryEvent` - not supported yet.  **Note**: When `collectOffers` is waiting, simultaneous call to `unsubscribeDemand` on the same `subscriptionId` should result in \"Subscription does not exist\" error returned from `collectOffers`.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet.
     * @summary CollectOffers - Reads Market responses to published Demand.
     * @param {string} subscriptionId
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    collectOffers(subscriptionId, timeout, maxEvents, options) {
        return exports.RequestorApiFp(this.configuration).collectOffers(subscriptionId, timeout, maxEvents, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Signs self-created Agreement and sends it to the Provider.  This call should immediately follow `createAgreement`.
     * @summary ConfirmAgreement - Sends Agreement proposal to the Provider.
     * @param {string} agreementId
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    confirmAgreement(agreementId, appSessionId, options) {
        return exports.RequestorApiFp(this.configuration).confirmAgreement(agreementId, appSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to `Draft`. Returns created Proposal id.
     * @summary CounterProposalDemand - Responds with a bespoke Demand to received Offer.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    counterProposalDemand(subscriptionId, proposalId, demandOfferBase, options) {
        return exports.RequestorApiFp(this.configuration).counterProposalDemand(subscriptionId, proposalId, demandOfferBase, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in `Proposal` state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to `createAgreement` shall immediately be followed by a `confirmAgreement` and `waitForApproval` call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to `Approved` state.
     * @summary CreateAgreement - Creates Agreement from selected Proposal.
     * @param {AgreementProposal} agreementProposal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    createAgreement(agreementProposal, options) {
        return exports.RequestorApiFp(this.configuration).createAgreement(agreementProposal, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GetAgreement - Fetches agreement with given agreement id.
     * @param {string} agreementId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getAgreement(agreementId, options) {
        return exports.RequestorApiFp(this.configuration).getAgreement(agreementId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GetDemands - Fetches all active Demands which have been published by the Requestor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getDemands(options) {
        return exports.RequestorApiFp(this.configuration).getDemands(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GetProposalOffer - Fetches Proposal (Offer) with given id.
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getProposalOffer(subscriptionId, proposalId, options) {
        return exports.RequestorApiFp(this.configuration).getProposalOffer(subscriptionId, proposalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2.
     * @summary QueryReplyDemands - Handles dynamic property query.
     * @param {string} subscriptionId
     * @param {string} queryId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    queryReplyDemands(subscriptionId, queryId, body, options) {
        return exports.RequestorApiFp(this.configuration).queryReplyDemands(subscriptionId, queryId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal.
     * @summary RejectProposalOffer - Rejects Proposal (Offer).
     * @param {string} subscriptionId
     * @param {string} proposalId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    rejectProposalOffer(subscriptionId, proposalId, requestBody, options) {
        return exports.RequestorApiFp(this.configuration).rejectProposalOffer(subscriptionId, proposalId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Demand object can be considered an \"open\" or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \"atomic\" operation, ie. as soon as Subscription is placed, the Demand is published on the market.
     * @summary SubscribeDemand - Publishes Requestor capabilities via Demand.
     * @param {DemandOfferBase} demandOfferBase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    subscribeDemand(demandOfferBase, options) {
        return exports.RequestorApiFp(this.configuration).subscribeDemand(demandOfferBase, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Method to finish/close the Agreement while in `Approved` state.  The other party gets notified about calling party decision to terminate a \"running\" agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification.
     * @summary TerminateAgreement - Terminates approved Agreement.
     * @param {string} agreementId
     * @param {{ [key: string]: object; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    terminateAgreement(agreementId, requestBody, options) {
        return exports.RequestorApiFp(this.configuration).terminateAgreement(agreementId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Stop receiving Proposals.  **Note**: this will terminate all pending `collectOffers` calls on this subscription. This implies, that client code should not `unsubscribeDemand` before it has received all expected/useful inputs from `collectOffers`.
     * @summary UnsubscribeDemand - Stop subscription for previously published Demand.
     * @param {string} subscriptionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    unsubscribeDemand(subscriptionId, options) {
        return exports.RequestorApiFp(this.configuration).unsubscribeDemand(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another `waitForApproval` call can be raised on the same Agreement Id.
     * @summary WaitForApproval - Waits for Agreement approval by the Provider.
     * @param {string} agreementId
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    waitForApproval(agreementId, timeout, options) {
        return exports.RequestorApiFp(this.configuration).waitForApproval(agreementId, timeout, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RequestorApi = RequestorApi;
