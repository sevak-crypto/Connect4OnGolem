"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytes = exports.parseHex = exports.toHex = exports.u64Flag = exports.toU64 = exports.toU32 = exports.toU16 = exports.toU8 = exports.LITTLE_ENDIAN = void 0;
exports.LITTLE_ENDIAN = true;
exports.toU8 = (n) => (n & 0xff);
exports.toU16 = (n) => (n & 0xffff);
exports.toU32 = (n) => (n & 0xffffffff);
exports.toU64 = (src) => {
    let buf;
    if (typeof src == "number") {
        buf = new Uint8Array(8);
        new DataView(buf.buffer, 0).setUint32(0, src & 0xffffffff, true);
    }
    else {
        buf = src;
    }
    return bytes.Bytes8.from(buf);
};
exports.u64Flag = (l, r) => {
    let li = l.inner;
    let ri = r.inner;
    let len = Math.min(li.length, ri.length);
    for (let i = 0; i < len; ++i) {
        if ((li[i] & ri[i]) != ri[i])
            return false;
    }
    return true;
};
exports.toHex = (arr) => {
    const map = (x) => ('00' + x.toString(16)).slice(-2);
    return Array.prototype.map.call(arr, map).join('');
};
exports.parseHex = (str) => {
    let arr = str.replace(/../g, '$&_')
        .slice(0, -1)
        .split('_')
        .map(h => parseInt(h, 16));
    return new Uint8Array(arr);
};
var bytes;
(function (bytes) {
    class Bytes {
        constructor(arr) {
            this.inner = arr;
        }
        static default() {
            return new Bytes(new Uint8Array(this.size));
        }
        static from(arr, offset = 0) {
            let slice = arr.slice(offset, offset + this.size);
            if (slice.byteLength == this.size) {
                return new Bytes(slice);
            }
            throw new Error(`Invalid length: ${arr.byteLength} != ${this.size} (expected)`);
        }
        static fromHex(hex) {
            let arr = exports.parseHex(hex);
            if (arr.byteLength != bytes.Bytes32.size) {
                throw new Error("Invalid measurement byte length");
            }
            return bytes.Bytes32.from(arr);
        }
        eq(other) {
            if (this.inner.length != other.inner.length) {
                return false;
            }
            for (let i = 0; i < this.inner.length; ++i) {
                if (this.inner[i] != other.inner[i])
                    return false;
            }
            return true;
        }
        partialEq(other) {
            let len = Math.min(this.inner.length, other.length);
            for (let i = 0; i < len; ++i) {
                if (this.inner[i] != other[i])
                    return false;
            }
            return true;
        }
        into() {
            return this.inner;
        }
        toString(radix = 16) {
            if (radix != 16) {
                throw new Error(`Unsupported radix: ${radix}`);
            }
            return exports.toHex(this.inner);
        }
    }
    Bytes.size = 0;
    bytes.Bytes = Bytes;
    class Bytes2 extends Bytes {
    }
    Bytes2.size = 2;
    bytes.Bytes2 = Bytes2;
    class Bytes4 extends Bytes {
    }
    Bytes4.size = 4;
    bytes.Bytes4 = Bytes4;
    class Bytes8 extends Bytes {
    }
    Bytes8.size = 8;
    bytes.Bytes8 = Bytes8;
    class Bytes12 extends Bytes {
    }
    Bytes12.size = 12;
    bytes.Bytes12 = Bytes12;
    class Bytes16 extends Bytes {
    }
    Bytes16.size = 16;
    bytes.Bytes16 = Bytes16;
    class Bytes32 extends Bytes {
    }
    Bytes32.size = 32;
    bytes.Bytes32 = Bytes32;
    class Bytes42 extends Bytes {
    }
    Bytes42.size = 42;
    bytes.Bytes42 = Bytes42;
    class Bytes64 extends Bytes {
    }
    Bytes64.size = 64;
    bytes.Bytes64 = Bytes64;
    class Bytes384 extends Bytes {
    }
    Bytes384.size = 384;
    bytes.Bytes384 = Bytes384;
})(bytes = exports.bytes || (exports.bytes = {}));
//# sourceMappingURL=types.js.map