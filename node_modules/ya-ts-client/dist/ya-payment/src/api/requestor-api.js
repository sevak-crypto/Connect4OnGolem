"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Yagna Payment API
 *  Invoicing and Payments is a fundamental area of Yagna Ecosystem functionality. It includes aspects of communication between Requestor, Provider and a selected Payment Platform, which becomes crucial when Activities are executed in the context of negotiated Agreements. Yagna applications must be able to exercise various payment models, and the Invoicing/Payment-related communication is happening in parallel to Activity control communication. To define functional patterns of Requestor/Provider interaction in this area, Payment API is specified.  An important principle of the Yagna Payment API is that the actual payment transactions are hidden behind the Invoice flow. In other words, a Yagna Application on Requestor side isn’t expected to trigger actual payment transactions. Instead it is expected to receive and accept Invoices raised by the Provider - based on Application’s Invoice Accept notifications, the Payment API implementation orchestrates the payment via a configured Payment platform.  **NOTE: This specification is work-in-progress.**
 *
 * The version of the OpenAPI document: 1.6.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestorApi = exports.RequestorApiFactory = exports.RequestorApiFp = exports.RequestorApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("../../base");
/**
 * RequestorApi - axios parameter creator
 * @export
 */
exports.RequestorApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Send Debit Note Accepted message to Debit Note Issuer. Trigger payment orchestration for this Debit Note (using allocated lot identified by AllocationId if any).  This is a blocking operation. It will not return until the Requestor has acknowledged accepting the Invoice or timeout has passed.  NOTE: An Accepted Debit Note cannot be Rejected later.
         * @summary Accept received Debit Note.
         * @param {string} debitNoteId
         * @param {Acceptance} acceptance
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDebitNote: (debitNoteId, acceptance, timeout, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'debitNoteId' is not null or undefined
            if (debitNoteId === null || debitNoteId === undefined) {
                throw new base_1.RequiredError('debitNoteId', 'Required parameter debitNoteId was null or undefined when calling acceptDebitNote.');
            }
            // verify required parameter 'acceptance' is not null or undefined
            if (acceptance === null || acceptance === undefined) {
                throw new base_1.RequiredError('acceptance', 'Required parameter acceptance was null or undefined when calling acceptDebitNote.');
            }
            const localVarPath = `/debitNotes/{debitNoteId}/accept`
                .replace(`{${"debitNoteId"}}`, encodeURIComponent(String(debitNoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof acceptance !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(acceptance !== undefined ? acceptance : {})
                : (acceptance || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Send Invoice Accepted message to Invoice Issuer. Trigger payment orchestration for this Invoice (using allocated lot identified by AllocationId if any).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: An Accepted Invoice cannot be Rejected later.
         * @summary Accept received Invoice.
         * @param {string} invoiceId
         * @param {Acceptance} acceptance
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvoice: (invoiceId, acceptance, timeout, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new base_1.RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling acceptInvoice.');
            }
            // verify required parameter 'acceptance' is not null or undefined
            if (acceptance === null || acceptance === undefined) {
                throw new base_1.RequiredError('acceptance', 'Required parameter acceptance was null or undefined when calling acceptInvoice.');
            }
            const localVarPath = `/invoices/{invoiceId}/accept`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof acceptance !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(acceptance !== undefined ? acceptance : {})
                : (acceptance || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Amend Allocation.
         * @param {string} allocationId
         * @param {Allocation} allocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amendAllocation: (allocationId, allocation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new base_1.RequiredError('allocationId', 'Required parameter allocationId was null or undefined when calling amendAllocation.');
            }
            // verify required parameter 'allocation' is not null or undefined
            if (allocation === null || allocation === undefined) {
                throw new base_1.RequiredError('allocation', 'Required parameter allocation was null or undefined when calling amendAllocation.');
            }
            const localVarPath = `/allocations/{allocationId}`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof allocation !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(allocation !== undefined ? allocation : {})
                : (allocation || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allocate funds to make sure they are not spent elsewhere.
         * @summary Create Allocation.
         * @param {Allocation} allocation
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllocation: (allocation, afterTimestamp, maxItems, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'allocation' is not null or undefined
            if (allocation === null || allocation === undefined) {
                throw new base_1.RequiredError('allocation', 'Required parameter allocation was null or undefined when calling createAllocation.');
            }
            const localVarPath = `/allocations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxItems !== undefined) {
                localVarQueryParameter['maxItems'] = maxItems;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof allocation !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(allocation !== undefined ? allocation : {})
                : (allocation || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Allocation.
         * @param {string} allocationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocation: (allocationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new base_1.RequiredError('allocationId', 'Required parameter allocationId was null or undefined when calling getAllocation.');
            }
            const localVarPath = `/allocations/{allocationId}`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Allocations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocations: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/allocations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Debit Note.
         * @param {string} debitNoteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNote: (debitNoteId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'debitNoteId' is not null or undefined
            if (debitNoteId === null || debitNoteId === undefined) {
                throw new base_1.RequiredError('debitNoteId', 'Required parameter debitNoteId was null or undefined when calling getDebitNote.');
            }
            const localVarPath = `/debitNotes/{debitNoteId}`
                .replace(`{${"debitNoteId"}}`, encodeURIComponent(String(debitNoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. **Note:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Debit Note events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNoteEvents: (timeout, afterTimestamp, maxEvents, appSessionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/debitNoteEvents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxEvents !== undefined) {
                localVarQueryParameter['maxEvents'] = maxEvents;
            }
            if (appSessionId !== undefined) {
                localVarQueryParameter['appSessionId'] = appSessionId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Debit Notes known by this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNotes: (afterTimestamp, maxItems, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/debitNotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxItems !== undefined) {
                localVarQueryParameter['maxItems'] = maxItems;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generate payment-related properties and constraints to be added to a demand published on the marketplace. As a parameter it accepts a list of IDs of allocations to be used to pay for invoices resulting from the decorated demand.
         * @summary Obtain Demand elements specific to the given allocations, to be appended to a market Demand.
         * @param {Array<string>} allocationIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemandDecorations: (allocationIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'allocationIds' is not null or undefined
            if (allocationIds === null || allocationIds === undefined) {
                throw new base_1.RequiredError('allocationIds', 'Required parameter allocationIds was null or undefined when calling getDemandDecorations.');
            }
            const localVarPath = `/demandDecorations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (allocationIds) {
                localVarQueryParameter['allocationIds'] = allocationIds.join(base_1.COLLECTION_FORMATS.csv);
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Invoice.
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: (invoiceId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new base_1.RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling getInvoice.');
            }
            const localVarPath = `/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. **Note:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Invoice events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceEvents: (timeout, afterTimestamp, maxEvents, appSessionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/invoiceEvents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxEvents !== undefined) {
                localVarQueryParameter['maxEvents'] = maxEvents;
            }
            if (appSessionId !== undefined) {
                localVarQueryParameter['appSessionId'] = appSessionId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Invoices known to this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices: (afterTimestamp, maxItems, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxItems !== undefined) {
                localVarQueryParameter['maxItems'] = maxItems;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Payment.
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: (paymentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new base_1.RequiredError('paymentId', 'Required parameter paymentId was null or undefined when calling getPayment.');
            }
            const localVarPath = `/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed.
         * @summary Get Payments.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments: (timeout, afterTimestamp, maxEvents, appSessionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxEvents !== undefined) {
                localVarQueryParameter['maxEvents'] = maxEvents;
            }
            if (appSessionId !== undefined) {
                localVarQueryParameter['appSessionId'] = appSessionId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Payments for Debit Note.
         * @param {string} debitNoteId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForDebitNote: (debitNoteId, afterTimestamp, maxItems, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'debitNoteId' is not null or undefined
            if (debitNoteId === null || debitNoteId === undefined) {
                throw new base_1.RequiredError('debitNoteId', 'Required parameter debitNoteId was null or undefined when calling getPaymentsForDebitNote.');
            }
            const localVarPath = `/debitNotes/{debitNoteId}/payments`
                .replace(`{${"debitNoteId"}}`, encodeURIComponent(String(debitNoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxItems !== undefined) {
                localVarQueryParameter['maxItems'] = maxItems;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Payments for Invoice.
         * @param {string} invoiceId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForInvoice: (invoiceId, afterTimestamp, maxItems, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new base_1.RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling getPaymentsForInvoice.');
            }
            const localVarPath = `/invoices/{invoiceId}/payments`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxItems !== undefined) {
                localVarQueryParameter['maxItems'] = maxItems;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get available accounts for sending payments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestorAccounts: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/requestorAccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Issue an Invoice.
         * @param {Invoice} invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueInvoice: (invoice, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoice' is not null or undefined
            if (invoice === null || invoice === undefined) {
                throw new base_1.RequiredError('invoice', 'Required parameter invoice was null or undefined when calling issueInvoice.');
            }
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof invoice !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(invoice !== undefined ? invoice : {})
                : (invoice || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Send Debit Note Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept the Debit Note (for some reason).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: A Rejected Debit Note can be Accepted subsequently (e.g. as a result of some arbitrage).
         * @summary Reject received Debit Note.
         * @param {string} debitNoteId
         * @param {Rejection} rejection
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectDebitNote: (debitNoteId, rejection, timeout, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'debitNoteId' is not null or undefined
            if (debitNoteId === null || debitNoteId === undefined) {
                throw new base_1.RequiredError('debitNoteId', 'Required parameter debitNoteId was null or undefined when calling rejectDebitNote.');
            }
            // verify required parameter 'rejection' is not null or undefined
            if (rejection === null || rejection === undefined) {
                throw new base_1.RequiredError('rejection', 'Required parameter rejection was null or undefined when calling rejectDebitNote.');
            }
            const localVarPath = `/debitNotes/{debitNoteId}/reject`
                .replace(`{${"debitNoteId"}}`, encodeURIComponent(String(debitNoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof rejection !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(rejection !== undefined ? rejection : {})
                : (rejection || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Send Invoice Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept Invoice (for some reason).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: A Rejected Invoice can be Accepted subsequently (e.g. as a result of some arbitrage).
         * @summary Reject received Invoice.
         * @param {string} invoiceId
         * @param {Rejection} rejection
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectInvoice: (invoiceId, rejection, timeout, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new base_1.RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling rejectInvoice.');
            }
            // verify required parameter 'rejection' is not null or undefined
            if (rejection === null || rejection === undefined) {
                throw new base_1.RequiredError('rejection', 'Required parameter rejection was null or undefined when calling rejectInvoice.');
            }
            const localVarPath = `/invoices/{invoiceId}/reject`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof rejection !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(rejection !== undefined ? rejection : {})
                : (rejection || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * The Allocation of amount is released. Note that this operation releases currently allocated amount (which may have been reduced by subsequent Invoice Payments).  If the Allocation was connected with a Deposit the release amount from Deposit shall be marked as pending to be paid back to Requestor - and eventually will be paid back, unless a subsequent Allocation with Deposit is made. The Payment Platform implementations may optimize unnecessary fund transfers (i.e. will not pay back the Deposit if released funds can be assigned to a new Allocation with Deposit).
         * @summary Release Allocation.
         * @param {string} allocationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseAllocation: (allocationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new base_1.RequiredError('allocationId', 'Required parameter allocationId was null or undefined when calling releaseAllocation.');
            }
            const localVarPath = `/allocations/{allocationId}`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? yield configuration.accessToken()
                    : yield configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * RequestorApi - functional programming interface
 * @export
 */
exports.RequestorApiFp = function (configuration) {
    return {
        /**
         * Send Debit Note Accepted message to Debit Note Issuer. Trigger payment orchestration for this Debit Note (using allocated lot identified by AllocationId if any).  This is a blocking operation. It will not return until the Requestor has acknowledged accepting the Invoice or timeout has passed.  NOTE: An Accepted Debit Note cannot be Rejected later.
         * @summary Accept received Debit Note.
         * @param {string} debitNoteId
         * @param {Acceptance} acceptance
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDebitNote(debitNoteId, acceptance, timeout, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).acceptDebitNote(debitNoteId, acceptance, timeout, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Send Invoice Accepted message to Invoice Issuer. Trigger payment orchestration for this Invoice (using allocated lot identified by AllocationId if any).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: An Accepted Invoice cannot be Rejected later.
         * @summary Accept received Invoice.
         * @param {string} invoiceId
         * @param {Acceptance} acceptance
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvoice(invoiceId, acceptance, timeout, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).acceptInvoice(invoiceId, acceptance, timeout, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Amend Allocation.
         * @param {string} allocationId
         * @param {Allocation} allocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amendAllocation(allocationId, allocation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).amendAllocation(allocationId, allocation, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Allocate funds to make sure they are not spent elsewhere.
         * @summary Create Allocation.
         * @param {Allocation} allocation
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllocation(allocation, afterTimestamp, maxItems, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).createAllocation(allocation, afterTimestamp, maxItems, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Allocation.
         * @param {string} allocationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocation(allocationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getAllocation(allocationId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Allocations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocations(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getAllocations(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Debit Note.
         * @param {string} debitNoteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNote(debitNoteId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getDebitNote(debitNoteId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. **Note:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Debit Note events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Debit Notes known by this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNotes(afterTimestamp, maxItems, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getDebitNotes(afterTimestamp, maxItems, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Generate payment-related properties and constraints to be added to a demand published on the marketplace. As a parameter it accepts a list of IDs of allocations to be used to pay for invoices resulting from the decorated demand.
         * @summary Obtain Demand elements specific to the given allocations, to be appended to a market Demand.
         * @param {Array<string>} allocationIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemandDecorations(allocationIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getDemandDecorations(allocationIds, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Invoice.
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(invoiceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getInvoice(invoiceId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. **Note:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Invoice events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Invoices known to this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(afterTimestamp, maxItems, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getInvoices(afterTimestamp, maxItems, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Payment.
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getPayment(paymentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed.
         * @summary Get Payments.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Payments for Debit Note.
         * @param {string} debitNoteId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Payments for Invoice.
         * @param {string} invoiceId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get available accounts for sending payments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestorAccounts(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).getRequestorAccounts(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Issue an Invoice.
         * @param {Invoice} invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueInvoice(invoice, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).issueInvoice(invoice, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Send Debit Note Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept the Debit Note (for some reason).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: A Rejected Debit Note can be Accepted subsequently (e.g. as a result of some arbitrage).
         * @summary Reject received Debit Note.
         * @param {string} debitNoteId
         * @param {Rejection} rejection
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectDebitNote(debitNoteId, rejection, timeout, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).rejectDebitNote(debitNoteId, rejection, timeout, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Send Invoice Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept Invoice (for some reason).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: A Rejected Invoice can be Accepted subsequently (e.g. as a result of some arbitrage).
         * @summary Reject received Invoice.
         * @param {string} invoiceId
         * @param {Rejection} rejection
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectInvoice(invoiceId, rejection, timeout, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).rejectInvoice(invoiceId, rejection, timeout, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * The Allocation of amount is released. Note that this operation releases currently allocated amount (which may have been reduced by subsequent Invoice Payments).  If the Allocation was connected with a Deposit the release amount from Deposit shall be marked as pending to be paid back to Requestor - and eventually will be paid back, unless a subsequent Allocation with Deposit is made. The Payment Platform implementations may optimize unnecessary fund transfers (i.e. will not pay back the Deposit if released funds can be assigned to a new Allocation with Deposit).
         * @summary Release Allocation.
         * @param {string} allocationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseAllocation(allocationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RequestorApiAxiosParamCreator(configuration).releaseAllocation(allocationId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * RequestorApi - factory interface
 * @export
 */
exports.RequestorApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Send Debit Note Accepted message to Debit Note Issuer. Trigger payment orchestration for this Debit Note (using allocated lot identified by AllocationId if any).  This is a blocking operation. It will not return until the Requestor has acknowledged accepting the Invoice or timeout has passed.  NOTE: An Accepted Debit Note cannot be Rejected later.
         * @summary Accept received Debit Note.
         * @param {string} debitNoteId
         * @param {Acceptance} acceptance
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDebitNote(debitNoteId, acceptance, timeout, options) {
            return exports.RequestorApiFp(configuration).acceptDebitNote(debitNoteId, acceptance, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * Send Invoice Accepted message to Invoice Issuer. Trigger payment orchestration for this Invoice (using allocated lot identified by AllocationId if any).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: An Accepted Invoice cannot be Rejected later.
         * @summary Accept received Invoice.
         * @param {string} invoiceId
         * @param {Acceptance} acceptance
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvoice(invoiceId, acceptance, timeout, options) {
            return exports.RequestorApiFp(configuration).acceptInvoice(invoiceId, acceptance, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Amend Allocation.
         * @param {string} allocationId
         * @param {Allocation} allocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amendAllocation(allocationId, allocation, options) {
            return exports.RequestorApiFp(configuration).amendAllocation(allocationId, allocation, options).then((request) => request(axios, basePath));
        },
        /**
         * Allocate funds to make sure they are not spent elsewhere.
         * @summary Create Allocation.
         * @param {Allocation} allocation
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllocation(allocation, afterTimestamp, maxItems, options) {
            return exports.RequestorApiFp(configuration).createAllocation(allocation, afterTimestamp, maxItems, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Allocation.
         * @param {string} allocationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocation(allocationId, options) {
            return exports.RequestorApiFp(configuration).getAllocation(allocationId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Allocations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocations(options) {
            return exports.RequestorApiFp(configuration).getAllocations(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Debit Note.
         * @param {string} debitNoteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNote(debitNoteId, options) {
            return exports.RequestorApiFp(configuration).getDebitNote(debitNoteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. **Note:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Debit Note events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return exports.RequestorApiFp(configuration).getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Debit Notes known by this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNotes(afterTimestamp, maxItems, options) {
            return exports.RequestorApiFp(configuration).getDebitNotes(afterTimestamp, maxItems, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate payment-related properties and constraints to be added to a demand published on the marketplace. As a parameter it accepts a list of IDs of allocations to be used to pay for invoices resulting from the decorated demand.
         * @summary Obtain Demand elements specific to the given allocations, to be appended to a market Demand.
         * @param {Array<string>} allocationIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemandDecorations(allocationIds, options) {
            return exports.RequestorApiFp(configuration).getDemandDecorations(allocationIds, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Invoice.
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(invoiceId, options) {
            return exports.RequestorApiFp(configuration).getInvoice(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. **Note:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Invoice events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return exports.RequestorApiFp(configuration).getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Invoices known to this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(afterTimestamp, maxItems, options) {
            return exports.RequestorApiFp(configuration).getInvoices(afterTimestamp, maxItems, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Payment.
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId, options) {
            return exports.RequestorApiFp(configuration).getPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed.
         * @summary Get Payments.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return exports.RequestorApiFp(configuration).getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Payments for Debit Note.
         * @param {string} debitNoteId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options) {
            return exports.RequestorApiFp(configuration).getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Payments for Invoice.
         * @param {string} invoiceId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options) {
            return exports.RequestorApiFp(configuration).getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get available accounts for sending payments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestorAccounts(options) {
            return exports.RequestorApiFp(configuration).getRequestorAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Issue an Invoice.
         * @param {Invoice} invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueInvoice(invoice, options) {
            return exports.RequestorApiFp(configuration).issueInvoice(invoice, options).then((request) => request(axios, basePath));
        },
        /**
         * Send Debit Note Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept the Debit Note (for some reason).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: A Rejected Debit Note can be Accepted subsequently (e.g. as a result of some arbitrage).
         * @summary Reject received Debit Note.
         * @param {string} debitNoteId
         * @param {Rejection} rejection
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectDebitNote(debitNoteId, rejection, timeout, options) {
            return exports.RequestorApiFp(configuration).rejectDebitNote(debitNoteId, rejection, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * Send Invoice Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept Invoice (for some reason).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: A Rejected Invoice can be Accepted subsequently (e.g. as a result of some arbitrage).
         * @summary Reject received Invoice.
         * @param {string} invoiceId
         * @param {Rejection} rejection
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectInvoice(invoiceId, rejection, timeout, options) {
            return exports.RequestorApiFp(configuration).rejectInvoice(invoiceId, rejection, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * The Allocation of amount is released. Note that this operation releases currently allocated amount (which may have been reduced by subsequent Invoice Payments).  If the Allocation was connected with a Deposit the release amount from Deposit shall be marked as pending to be paid back to Requestor - and eventually will be paid back, unless a subsequent Allocation with Deposit is made. The Payment Platform implementations may optimize unnecessary fund transfers (i.e. will not pay back the Deposit if released funds can be assigned to a new Allocation with Deposit).
         * @summary Release Allocation.
         * @param {string} allocationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseAllocation(allocationId, options) {
            return exports.RequestorApiFp(configuration).releaseAllocation(allocationId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RequestorApi - object-oriented interface
 * @export
 * @class RequestorApi
 * @extends {BaseAPI}
 */
class RequestorApi extends base_1.BaseAPI {
    /**
     * Send Debit Note Accepted message to Debit Note Issuer. Trigger payment orchestration for this Debit Note (using allocated lot identified by AllocationId if any).  This is a blocking operation. It will not return until the Requestor has acknowledged accepting the Invoice or timeout has passed.  NOTE: An Accepted Debit Note cannot be Rejected later.
     * @summary Accept received Debit Note.
     * @param {string} debitNoteId
     * @param {Acceptance} acceptance
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    acceptDebitNote(debitNoteId, acceptance, timeout, options) {
        return exports.RequestorApiFp(this.configuration).acceptDebitNote(debitNoteId, acceptance, timeout, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send Invoice Accepted message to Invoice Issuer. Trigger payment orchestration for this Invoice (using allocated lot identified by AllocationId if any).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: An Accepted Invoice cannot be Rejected later.
     * @summary Accept received Invoice.
     * @param {string} invoiceId
     * @param {Acceptance} acceptance
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    acceptInvoice(invoiceId, acceptance, timeout, options) {
        return exports.RequestorApiFp(this.configuration).acceptInvoice(invoiceId, acceptance, timeout, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Amend Allocation.
     * @param {string} allocationId
     * @param {Allocation} allocation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    amendAllocation(allocationId, allocation, options) {
        return exports.RequestorApiFp(this.configuration).amendAllocation(allocationId, allocation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allocate funds to make sure they are not spent elsewhere.
     * @summary Create Allocation.
     * @param {Allocation} allocation
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxItems] Maximum number of items that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    createAllocation(allocation, afterTimestamp, maxItems, options) {
        return exports.RequestorApiFp(this.configuration).createAllocation(allocation, afterTimestamp, maxItems, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Allocation.
     * @param {string} allocationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getAllocation(allocationId, options) {
        return exports.RequestorApiFp(this.configuration).getAllocation(allocationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Allocations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getAllocations(options) {
        return exports.RequestorApiFp(this.configuration).getAllocations(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Debit Note.
     * @param {string} debitNoteId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getDebitNote(debitNoteId, options) {
        return exports.RequestorApiFp(this.configuration).getDebitNote(debitNoteId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. **Note:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
     * @summary Get Debit Note events.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
        return exports.RequestorApiFp(this.configuration).getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Debit Notes known by this node (either issued by this Provider or received by this Requestor).
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxItems] Maximum number of items that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getDebitNotes(afterTimestamp, maxItems, options) {
        return exports.RequestorApiFp(this.configuration).getDebitNotes(afterTimestamp, maxItems, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generate payment-related properties and constraints to be added to a demand published on the marketplace. As a parameter it accepts a list of IDs of allocations to be used to pay for invoices resulting from the decorated demand.
     * @summary Obtain Demand elements specific to the given allocations, to be appended to a market Demand.
     * @param {Array<string>} allocationIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getDemandDecorations(allocationIds, options) {
        return exports.RequestorApiFp(this.configuration).getDemandDecorations(allocationIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Invoice.
     * @param {string} invoiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getInvoice(invoiceId, options) {
        return exports.RequestorApiFp(this.configuration).getInvoice(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. **Note:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
     * @summary Get Invoice events.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
        return exports.RequestorApiFp(this.configuration).getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Invoices known to this node (either issued by this Provider or received by this Requestor).
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxItems] Maximum number of items that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getInvoices(afterTimestamp, maxItems, options) {
        return exports.RequestorApiFp(this.configuration).getInvoices(afterTimestamp, maxItems, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Payment.
     * @param {string} paymentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getPayment(paymentId, options) {
        return exports.RequestorApiFp(this.configuration).getPayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed.
     * @summary Get Payments.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options) {
        return exports.RequestorApiFp(this.configuration).getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Payments for Debit Note.
     * @param {string} debitNoteId
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxItems] Maximum number of items that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options) {
        return exports.RequestorApiFp(this.configuration).getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Payments for Invoice.
     * @param {string} invoiceId
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxItems] Maximum number of items that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options) {
        return exports.RequestorApiFp(this.configuration).getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get available accounts for sending payments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    getRequestorAccounts(options) {
        return exports.RequestorApiFp(this.configuration).getRequestorAccounts(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Issue an Invoice.
     * @param {Invoice} invoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    issueInvoice(invoice, options) {
        return exports.RequestorApiFp(this.configuration).issueInvoice(invoice, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send Debit Note Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept the Debit Note (for some reason).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: A Rejected Debit Note can be Accepted subsequently (e.g. as a result of some arbitrage).
     * @summary Reject received Debit Note.
     * @param {string} debitNoteId
     * @param {Rejection} rejection
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    rejectDebitNote(debitNoteId, rejection, timeout, options) {
        return exports.RequestorApiFp(this.configuration).rejectDebitNote(debitNoteId, rejection, timeout, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send Invoice Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept Invoice (for some reason).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: A Rejected Invoice can be Accepted subsequently (e.g. as a result of some arbitrage).
     * @summary Reject received Invoice.
     * @param {string} invoiceId
     * @param {Rejection} rejection
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    rejectInvoice(invoiceId, rejection, timeout, options) {
        return exports.RequestorApiFp(this.configuration).rejectInvoice(invoiceId, rejection, timeout, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The Allocation of amount is released. Note that this operation releases currently allocated amount (which may have been reduced by subsequent Invoice Payments).  If the Allocation was connected with a Deposit the release amount from Deposit shall be marked as pending to be paid back to Requestor - and eventually will be paid back, unless a subsequent Allocation with Deposit is made. The Payment Platform implementations may optimize unnecessary fund transfers (i.e. will not pay back the Deposit if released funds can be assigned to a new Allocation with Deposit).
     * @summary Release Allocation.
     * @param {string} allocationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestorApi
     */
    releaseAllocation(allocationId, options) {
        return exports.RequestorApiFp(this.configuration).releaseAllocation(allocationId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RequestorApi = RequestorApi;
