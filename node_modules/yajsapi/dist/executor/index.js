"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Executor = exports._BufferItem = exports._ExecutorConfig = exports.NoPaymentAccountError = exports.TaskStatus = exports.Task = exports.vm = exports.sgx = void 0;
const bluebird_1 = __importStar(require("bluebird"));
const dayjs_1 = __importDefault(require("dayjs"));
const utc_1 = __importDefault(require("dayjs/plugin/utc"));
const duration_1 = __importDefault(require("dayjs/plugin/duration"));
const ctx_1 = require("./ctx");
const events = __importStar(require("./events"));
const props_1 = require("../props");
const com_1 = require("../props/com");
const builder_1 = require("../props/builder");
const rest = __importStar(require("../rest"));
const activity_1 = require("../rest/activity");
const csp = __importStar(require("js-csp"));
const gftp = __importStar(require("../storage/gftp"));
const utils_1 = require("../utils");
const _vm = __importStar(require("../package/vm"));
const _sgx = __importStar(require("../package/sgx"));
exports.sgx = _sgx;
exports.vm = _vm;
const task_1 = require("./task");
Object.defineProperty(exports, "Task", { enumerable: true, get: function () { return task_1.Task; } });
Object.defineProperty(exports, "TaskStatus", { enumerable: true, get: function () { return task_1.TaskStatus; } });
const smartq_1 = require("./smartq");
const strategy_1 = require("./strategy");
dayjs_1.default.extend(duration_1.default);
dayjs_1.default.extend(utc_1.default);
const SIGNALS = ["SIGINT", "SIGTERM", "SIGBREAK", "SIGHUP"];
const DEBIT_NOTE_MIN_TIMEOUT = 30;
const DEBIT_NOTE_ACCEPTANCE_TIMEOUT_PROP = "golem.com.payment.debit-notes.accept-timeout?";
const CFG_INVOICE_TIMEOUT = dayjs_1.default
    .duration({ minutes: 5 })
    .asMilliseconds();
const DEFAULT_EXECUTOR_TIMEOUT = dayjs_1.default
    .duration({ minutes: 15 })
    .asMilliseconds();
const DEFAULT_NETWORK = "rinkeby";
const DEFAULT_DRIVER = "zksync";
class NoPaymentAccountError extends Error {
    constructor(required_driver, required_network) {
        super(`No payment account available for driver ${required_driver} and network ${required_network}`);
        this.name = this.constructor.name;
        this.required_driver = required_driver;
        this.required_network = required_network;
    }
    toString() {
        return this.message;
    }
}
exports.NoPaymentAccountError = NoPaymentAccountError;
class _ExecutorConfig {
    constructor(max_workers, timeout) {
        this.max_workers = 5;
        this.timeout = DEFAULT_EXECUTOR_TIMEOUT;
        this.get_offers_timeout = dayjs_1.default.duration({ seconds: 20 }).asMilliseconds();
        this.traceback = false;
        this.max_workers = max_workers;
        this.timeout = timeout;
    }
}
exports._ExecutorConfig = _ExecutorConfig;
class _BufferItem {
    constructor(ts, score, proposal) {
        this.ts = ts;
        this.score = score;
        this.proposal = proposal;
    }
}
exports._BufferItem = _BufferItem;
class AsyncGeneratorBreak extends Error {
}
class Executor {
    constructor({ task_package, max_workers = 5, timeout = DEFAULT_EXECUTOR_TIMEOUT, budget, strategy, subnet_tag, driver, network, event_consumer, }) {
        this._subnet = subnet_tag;
        this._driver = driver ? driver.toLowerCase() : DEFAULT_DRIVER;
        this._network = network ? network.toLowerCase() : DEFAULT_NETWORK;
        this._stream_output = false;
        this._api_config = new rest.Configuration();
        this._stack = new utils_1.AsyncExitStack();
        this._task_package = task_package;
        this._conf = new _ExecutorConfig(max_workers, timeout);
        this._budget_amount = parseFloat(budget);
        this._strategy = strategy || new strategy_1.DecreaseScoreForUnconfirmedAgreement(new strategy_1.LeastExpensiveLinearPayuMS(60, 1.0, new Map([
            [com_1.Counter.TIME, 0.1],
            [com_1.Counter.CPU, 0.2]
        ])), 0.5);
        this._budget_allocations = [];
        this._rejecting_providers = new Set();
        this._cancellation_token = new utils_1.CancellationToken();
        let cancellationToken = this._cancellation_token;
        this._worker_cancellation_token = new utils_1.CancellationToken();
        let workerCancellationToken = this._worker_cancellation_token;
        this._payment_cancellation_token = new utils_1.CancellationToken();
        function cancel(event) {
            if (cancellationToken && !cancellationToken.cancelled) {
                cancellationToken.cancel();
            }
            if (workerCancellationToken && !workerCancellationToken.cancelled) {
                workerCancellationToken.cancel();
            }
            SIGNALS.forEach((event) => {
                process.off(event, cancel);
            });
        }
        SIGNALS.forEach((event) => process.on(event, cancel));
        if (!event_consumer) {
        }
        this._wrapped_consumer =
            event_consumer &&
                new utils_1.AsyncWrapper(event_consumer, null, cancellationToken);
        this._chan_computation_done = csp.chan();
        this._active_computations = 0;
    }
    async *submit(worker, data) {
        this._active_computations += 1;
        let generator = this._submit(worker, data);
        generator.return = async (value) => {
            csp.putAsync(this._chan_computation_done, true);
            await generator.throw(new AsyncGeneratorBreak());
            return { done: true, value: undefined };
        };
        yield* generator;
        csp.putAsync(this._chan_computation_done, true);
    }
    async *_submit(worker, data) {
        const emit = (this._wrapped_consumer.async_call.bind(this._wrapped_consumer));
        const multi_payment_decoration = await this._create_allocations();
        emit(new events.ComputationStarted({ expires: this._expires }));
        let builder = new builder_1.DemandBuilder();
        let _activity = new props_1.Activity();
        _activity.expiration.value = this._expires;
        _activity.multi_activity.value = true;
        builder.add(_activity);
        builder.add(new props_1.NodeInfo(this._subnet));
        if (this._subnet)
            builder.ensure(`(${props_1.NodeInfoKeys.subnet_tag}=${this._subnet})`);
        for (let constraint of multi_payment_decoration.constraints) {
            builder.ensure(constraint);
        }
        for (let x of multi_payment_decoration.properties) {
            builder._properties[x.key] = x.value;
        }
        await this._task_package.decorate_demand(builder);
        await this._strategy.decorate_demand(builder);
        let offer_buffer = {};
        let market_api = this._market_api;
        let activity_api = this._activity_api;
        let strategy = this._strategy;
        let cancellationToken = this._cancellation_token;
        let paymentCancellationToken = this._payment_cancellation_token;
        let done_queue = new utils_1.Queue([]);
        let stream_output = this._stream_output;
        function on_task_done(task, status) {
            if (status === task_1.TaskStatus.ACCEPTED)
                done_queue.put(task);
        }
        function* input_tasks() {
            for (let task of data) {
                task._add_callback(on_task_done);
                yield task;
            }
        }
        let work_queue = new smartq_1.SmartQueue([...input_tasks()]);
        let workers = new Set();
        let last_wid = 0;
        let self = this;
        let agreements_to_pay = new Set();
        let agreements_accepting_debit_notes = new Set();
        let invoices = new Map();
        let payment_closing = false;
        let secure = this._task_package.secure;
        let offers_collected = 0;
        let proposals_confirmed = 0;
        async function process_invoices() {
            for await (let invoice of self._payment_api.incoming_invoices(paymentCancellationToken)) {
                if (agreements_to_pay.has(invoice.agreementId)) {
                    emit(new events.InvoiceReceived({
                        agr_id: invoice.agreementId,
                        inv_id: invoice.invoiceId,
                        amount: invoice.amount,
                    }));
                    emit(new events.CheckingPayments());
                    const allocation = self._get_allocation(invoice);
                    try {
                        await invoice.accept(invoice.amount, allocation);
                        agreements_to_pay.delete(invoice.agreementId);
                        agreements_accepting_debit_notes.delete(invoice.agreementId);
                        emit(new events.PaymentAccepted({
                            agr_id: invoice.agreementId,
                            inv_id: invoice.invoiceId,
                            amount: invoice.amount,
                        }));
                    }
                    catch (e) {
                        emit(new events.PaymentFailed({ agr_id: invoice.agreementId, reason: e.toString() }));
                    }
                }
                else {
                    invoices[invoice.agreementId] = invoice;
                }
                if (payment_closing && agreements_to_pay.size === 0) {
                    break;
                }
            }
            if (!paymentCancellationToken.cancelled) {
                paymentCancellationToken.cancel();
            }
            utils_1.logger.debug("Stopped processing invoices.");
        }
        async function accept_payment_for_agreement({ agreement_id, partial, }) {
            emit(new events.PaymentPrepared({ agr_id: agreement_id }));
            let inv = invoices.get(agreement_id);
            if (!inv) {
                agreements_to_pay.add(agreement_id);
                emit(new events.PaymentQueued({ agr_id: agreement_id }));
                return;
            }
            invoices.delete(agreement_id);
            const allocation = self._get_allocation(inv);
            await inv.accept(inv.amount, allocation);
            emit(new events.PaymentAccepted({
                agr_id: agreement_id,
                inv_id: inv.invoiceId,
                amount: inv.amount,
            }));
        }
        async function process_debit_notes() {
            for await (let debit_note of self._payment_api.incoming_debit_notes(paymentCancellationToken)) {
                if (agreements_accepting_debit_notes.has(debit_note.agreementId)) {
                    emit(new events.DebitNoteReceived({
                        agr_id: debit_note.agreementId,
                        note_id: debit_note.debitNodeId,
                        amount: debit_note.totalAmountDue,
                    }));
                    const allocation = self._get_allocation(debit_note);
                    try {
                        await debit_note.accept(debit_note.totalAmountDue, allocation);
                    }
                    catch (e) {
                        emit(new events.PaymentFailed({ agr_id: debit_note.agreementId, reason: e.toString() }));
                    }
                }
                if (payment_closing && agreements_to_pay.size === 0) {
                    break;
                }
            }
            utils_1.logger.debug("Stopped processing debit notes.");
        }
        async function find_offers() {
            let _subscription;
            try {
                _subscription = await builder.subscribe(market_api);
            }
            catch (error) {
                emit(new events.SubscriptionFailed({ reason: error }));
                throw error;
            }
            await utils_1.asyncWith(_subscription, async (subscription) => {
                emit(new events.SubscriptionCreated({ sub_id: subscription.id() }));
                let _proposals;
                try {
                    _proposals = subscription.events(self._worker_cancellation_token);
                }
                catch (error) {
                    emit(new events.CollectFailed({
                        sub_id: subscription.id(),
                        reason: error,
                    }));
                }
                for await (let proposal of _proposals) {
                    emit(new events.ProposalReceived({
                        prop_id: proposal.id(),
                        provider_id: proposal.issuer(),
                    }));
                    offers_collected += 1;
                    let score;
                    try {
                        score = await strategy.score_offer(proposal, self);
                        utils_1.logger.debug(`Scored offer ${proposal.id()}, ` +
                            `provider: ${proposal.props()["golem.node.id.name"]}, ` +
                            `strategy: ${strategy.constructor.name}, ` +
                            `score: ${score}`);
                    }
                    catch (error) {
                        emit(new events.ProposalRejected({
                            prop_id: proposal.id(),
                            reason: error,
                        }));
                        continue;
                    }
                    if (score < strategy_1.SCORE_NEUTRAL) {
                        try {
                            const reason = "Score too low";
                            await proposal.reject(reason);
                            emit(new events.ProposalRejected({
                                prop_id: proposal.id(),
                                reason: reason,
                            }));
                        }
                        catch (error) {
                            utils_1.logger.log("debug", `Reject error: ${error}`);
                        }
                        continue;
                    }
                    if (!proposal.is_draft()) {
                        try {
                            const common_platforms = self._get_common_payment_platforms(proposal);
                            if (common_platforms.length) {
                                builder._properties["golem.com.payment.chosen-platform"] =
                                    common_platforms[0];
                            }
                            else {
                                try {
                                    const reason = "No common payment platforms";
                                    await proposal.reject(reason);
                                    emit(new events.ProposalRejected({
                                        prop_id: proposal.id,
                                        reason: reason,
                                    }));
                                }
                                catch (error) {
                                }
                            }
                            let timeout = proposal.props()[DEBIT_NOTE_ACCEPTANCE_TIMEOUT_PROP];
                            if (timeout) {
                                if (timeout < DEBIT_NOTE_MIN_TIMEOUT) {
                                    const reason = "Debit note acceptance timeout too short";
                                    try {
                                        await proposal.reject(reason);
                                    }
                                    catch (e) {
                                    }
                                    emit(new events.ProposalRejected({
                                        prop_id: proposal.id,
                                        reason: reason,
                                    }));
                                }
                                else {
                                    builder._properties[DEBIT_NOTE_ACCEPTANCE_TIMEOUT_PROP] = timeout;
                                }
                            }
                            await proposal.respond(builder.properties(), builder.constraints());
                            emit(new events.ProposalResponded({ prop_id: proposal.id() }));
                        }
                        catch (error) {
                            emit(new events.ProposalFailed({
                                prop_id: proposal.id(),
                                reason: error,
                            }));
                        }
                    }
                    else {
                        emit(new events.ProposalConfirmed({ prop_id: proposal.id() }));
                        offer_buffer[proposal.issuer()] = new _BufferItem(Date.now(), score, proposal);
                        proposals_confirmed += 1;
                    }
                }
            });
            utils_1.logger.debug("Stopped checking and scoring new offers.");
        }
        let storage_manager = await this._stack.enter_async_context(gftp.provider());
        async function start_worker(agreement) {
            let wid = last_wid;
            last_wid += 1;
            emit(new events.WorkerStarted({ agr_id: agreement.id() }));
            if (self._worker_cancellation_token.cancelled) {
                return;
            }
            let _act;
            try {
                _act = await activity_api.new_activity(agreement, secure);
            }
            catch (error) {
                emit(new events.ActivityCreateFailed({ agr_id: agreement.id() }));
                throw error;
            }
            async function* task_emitter(consumer) {
                for await (let handle of consumer) {
                    if (self._worker_cancellation_token.cancelled) {
                        break;
                    }
                    yield task_1.Task.for_handle(handle, work_queue, emit);
                }
            }
            await utils_1.asyncWith(_act, async (act) => {
                emit(new events.ActivityCreated({
                    act_id: act.id,
                    agr_id: agreement.id(),
                }));
                agreements_accepting_debit_notes.add(agreement.id());
                let work_context = new ctx_1.WorkContext(`worker-${wid}`, storage_manager, emit);
                await utils_1.asyncWith(work_queue.new_consumer(), async (consumer) => {
                    let command_generator = worker(work_context, task_emitter(consumer));
                    if (self._worker_cancellation_token.cancelled) {
                        return;
                    }
                    for await (let batch of command_generator) {
                        if (self._worker_cancellation_token.cancelled) {
                            return;
                        }
                        const _batch_timeout = batch.timeout();
                        const batch_deadline = _batch_timeout
                            ? dayjs_1.default.utc().unix() + _batch_timeout
                            : null;
                        try {
                            let current_worker_task = consumer.last_item();
                            if (current_worker_task) {
                                emit(new events.TaskStarted({
                                    agr_id: agreement.id(),
                                    task_id: current_worker_task.id,
                                    task_data: current_worker_task.data(),
                                }));
                            }
                            let task_id = current_worker_task
                                ? current_worker_task.id
                                : null;
                            batch.attestation = {
                                credentials: act.credentials,
                                nonce: act.id,
                                exeunitHashes: act.exeunitHashes,
                            };
                            if (self._worker_cancellation_token.cancelled) {
                                return;
                            }
                            await batch.prepare();
                            let cc = new ctx_1.CommandContainer();
                            batch.register(cc);
                            if (self._worker_cancellation_token.cancelled) {
                                return;
                            }
                            let remote = await act.send(cc.commands(), stream_output, batch_deadline, self._worker_cancellation_token);
                            let cmds = cc.commands();
                            emit(new events.ScriptSent({
                                agr_id: agreement.id(),
                                task_id,
                                cmds,
                            }));
                            emit(new events.CheckingPayments());
                            for await (let evt_ctx of remote) {
                                if (self._worker_cancellation_token.cancelled) {
                                    return;
                                }
                                let evt = evt_ctx.event(agreement.id(), task_id, cmds);
                                emit(evt);
                                if (evt instanceof events.CommandExecuted && !evt.success) {
                                    throw new activity_1.CommandExecutionError(evt.command, evt.message);
                                }
                            }
                            emit(new events.GettingResults({
                                agr_id: agreement.id(),
                                task_id: task_id,
                            }));
                            if (self._worker_cancellation_token.cancelled) {
                                return;
                            }
                            await batch.post();
                            emit(new events.ScriptFinished({
                                agr_id: agreement.id(),
                                task_id: task_id,
                            }));
                            if (self._worker_cancellation_token.cancelled) {
                                return;
                            }
                            await accept_payment_for_agreement({
                                agreement_id: agreement.id(),
                                partial: true,
                            });
                        }
                        catch (error) {
                            if (self._worker_cancellation_token.cancelled) {
                                return;
                            }
                            try {
                                await command_generator.throw(error);
                            }
                            catch (error) {
                                emit(new events.WorkerFinished({
                                    agr_id: agreement.id(),
                                    exception: error,
                                }));
                                return;
                            }
                        }
                    }
                });
                if (self._worker_cancellation_token.cancelled) {
                    return;
                }
                await accept_payment_for_agreement({
                    agreement_id: agreement.id(),
                    partial: false,
                });
                emit(new events.WorkerFinished({
                    agr_id: agreement.id(),
                    exception: undefined,
                }));
            });
            utils_1.logger.debug(`Stopped worker related to agreement ${agreement.id()}.`);
        }
        async function worker_starter() {
            async function _start_worker(agreement) {
                try {
                    await start_worker(agreement);
                }
                catch (error) {
                    utils_1.logger.warn(`Worker finished with error: ${error}`);
                }
                finally {
                    await agreement.terminate();
                }
            }
            while (true) {
                await utils_1.sleep(2);
                if (self._worker_cancellation_token.cancelled) {
                    break;
                }
                if (Object.keys(offer_buffer).length > 0 &&
                    workers.size < self._conf.max_workers &&
                    work_queue.has_unassigned_items()) {
                    let _offer_list = Object.entries(offer_buffer);
                    let _sample = _offer_list
                        .map(x => { return { obj: x, rnd: Math.random() }; })
                        .sort((a, b) => a.rnd - b.rnd)
                        .map(x => x.obj)
                        .reduce((acc, item) => item[1].score > acc[1].score ? item : acc);
                    let [provider_id, buffer] = _sample;
                    delete offer_buffer[provider_id];
                    let new_task = null;
                    let agreement = null;
                    try {
                        if (self._worker_cancellation_token.cancelled) {
                            break;
                        }
                        agreement = await buffer.proposal.create_agreement();
                        if (self._worker_cancellation_token.cancelled) {
                            break;
                        }
                        const node_info = (await agreement.details())
                            .provider_view()
                            .extract(new props_1.NodeInfo());
                        emit(new events.AgreementCreated({
                            agr_id: agreement.id(),
                            provider_id: provider_id,
                            provider_info: node_info,
                        }));
                        if (self._worker_cancellation_token.cancelled) {
                            break;
                        }
                        if (!(await agreement.confirm())) {
                            emit(new events.AgreementRejected({ agr_id: agreement.id() }));
                            self._rejecting_providers.add(provider_id);
                            continue;
                        }
                        self._rejecting_providers.delete(provider_id);
                        emit(new events.AgreementConfirmed({ agr_id: agreement.id() }));
                        if (self._worker_cancellation_token.cancelled) {
                            break;
                        }
                        new_task = loop.create_task(_start_worker.bind(null, agreement));
                        workers.add(new_task);
                    }
                    catch (error) {
                        if (new_task)
                            new_task.cancel();
                        emit(new events.ProposalFailed({
                            prop_id: buffer.proposal.id(),
                            reason: error.toString(),
                        }));
                    }
                }
            }
            utils_1.logger.debug("Stopped starting new tasks on providers.");
        }
        async function promise_timeout(seconds) {
            return bluebird_1.default.coroutine(function* () {
                yield utils_1.sleep(seconds);
            })();
        }
        let loop = utils_1.eventLoop();
        let find_offers_task = loop.create_task(find_offers);
        let process_invoices_job = loop.create_task(process_invoices);
        let wait_until_done = loop.create_task(work_queue.wait_until_done.bind(work_queue));
        let get_offers_deadline = dayjs_1.default.utc() + this._conf.get_offers_timeout;
        let get_done_task = null;
        let worker_starter_task = loop.create_task(worker_starter);
        let debit_notes_job = loop.create_task(process_debit_notes);
        let services = [
            find_offers_task,
            worker_starter_task,
            process_invoices_job,
            wait_until_done,
            debit_notes_job,
        ];
        try {
            while (services.indexOf(wait_until_done) > -1 || !done_queue.empty()) {
                if (cancellationToken.cancelled) {
                    work_queue.close();
                    done_queue.close();
                    break;
                }
                const now = dayjs_1.default.utc();
                if (now > this._expires) {
                    throw new bluebird_1.TimeoutError(`task timeout exceeded. timeout=${this._conf.timeout}`);
                }
                if (now > get_offers_deadline && proposals_confirmed == 0) {
                    emit(new events.NoProposalsConfirmed({
                        num_offers: offers_collected,
                        timeout: this._conf.get_offers_timeout,
                    }));
                    get_offers_deadline += this._conf.get_offers_timeout;
                }
                if (!get_done_task) {
                    get_done_task = loop.create_task(done_queue.get.bind(done_queue));
                    services.push(get_done_task);
                }
                await bluebird_1.default.Promise.any([
                    ...services,
                    ...workers,
                    promise_timeout(10),
                ]);
                workers = new Set([...workers].filter((worker) => worker.isPending()));
                services = services.filter((service) => service.isPending());
                if (!get_done_task)
                    throw "";
                if (!get_done_task.isPending()) {
                    const res = await get_done_task;
                    if (res) {
                        yield res;
                    }
                    else {
                        break;
                    }
                    if (services.indexOf(get_done_task) > -1)
                        throw "";
                    get_done_task = null;
                }
            }
            emit(new events.ComputationFinished());
        }
        catch (error) {
            if (error instanceof AsyncGeneratorBreak) {
                work_queue.close();
                done_queue.close();
                utils_1.logger.info("Break in the async for loop. Gracefully stopping all computations.");
            }
            else {
                utils_1.logger.error(`Computation Failed. Error: ${error}`);
            }
            if (!self._worker_cancellation_token.cancelled)
                self._worker_cancellation_token.cancel();
            emit(new events.ComputationFinished());
        }
        finally {
            if (cancellationToken.cancelled) {
                utils_1.logger.error("Computation interrupted by the user.");
            }
            payment_closing = true;
            find_offers_task.cancel();
            worker_starter_task.cancel();
            if (!self._worker_cancellation_token.cancelled)
                self._worker_cancellation_token.cancel();
            try {
                if (workers) {
                    for (let worker_task of [...workers]) {
                        worker_task.cancel();
                    }
                    emit(new events.CheckingPayments());
                    await bluebird_1.default.Promise.any([
                        bluebird_1.default.Promise.all([...workers]),
                        promise_timeout(10),
                    ]);
                    emit(new events.CheckingPayments());
                }
            }
            catch (error) {
                utils_1.logger.error(error);
            }
            await bluebird_1.default.Promise.any([
                bluebird_1.default.Promise.all([process_invoices_job, debit_notes_job]),
                promise_timeout(20),
            ]);
            emit(new events.CheckingPayments());
            if (agreements_to_pay.size > 0) {
                await bluebird_1.default.Promise.any([process_invoices_job, debit_notes_job, promise_timeout(15)]);
                emit(new events.CheckingPayments());
            }
        }
        if (!self._payment_cancellation_token.cancelled)
            self._payment_cancellation_token.cancel();
        emit(new events.PaymentsFinished());
        await utils_1.sleep(2);
        utils_1.logger.info("Shutting down...");
        cancellationToken.cancel();
        await utils_1.sleep(15);
        utils_1.logger.info("Shutdown complete.");
        return;
    }
    async _create_allocations() {
        if (!this._budget_allocations.length) {
            for await (let account of this._payment_api.accounts()) {
                let driver = account.driver ? account.driver.toLowerCase() : "";
                let network = account.driver ? account.network.toLowerCase() : "";
                if (driver != this._driver || network != this._network) {
                    utils_1.logger.debug(`Not using payment platform ${account.platform}, platform's driver/network ` +
                        `${driver}/${network} is different than requested ` +
                        `driver/network ${this._driver}/${this._network}`);
                    continue;
                }
                utils_1.logger.debug(`Creating allocation using payment platform ${account.platform}`);
                let allocation = await this._stack.enter_async_context(this._payment_api.new_allocation(this._budget_amount, account.platform, account.address, this._expires.add(CFG_INVOICE_TIMEOUT, "ms")));
                this._budget_allocations.push(allocation);
            }
            if (!this._budget_allocations.length) {
                throw new NoPaymentAccountError(this._driver, this._network);
            }
        }
        let allocation_ids = this._budget_allocations.map((a) => a.id);
        return await this._payment_api.decorate_demand(allocation_ids);
    }
    _get_common_payment_platforms(proposal) {
        let prov_platforms = Object.keys(proposal.props())
            .filter((prop) => {
            return prop.startsWith("golem.com.payment.platform.");
        })
            .map((prop) => {
            return prop.split(".")[4];
        });
        if (!prov_platforms) {
            prov_platforms = ["NGNT"];
        }
        const req_platforms = this._budget_allocations.map((budget_allocation) => budget_allocation.payment_platform);
        return req_platforms.filter((value) => value && prov_platforms.includes(value));
    }
    _get_allocation(item) {
        try {
            const _allocation = this._budget_allocations.find((allocation) => allocation.payment_platform === item.paymentPlatform &&
                allocation.payment_address === item.payerAddr);
            if (_allocation)
                return _allocation;
            throw `No allocation for ${item.paymentPlatform} ${item.payerAddr}.`;
        }
        catch (error) {
            throw new Error(error);
        }
    }
    rejected_last_agreement(provider_id) {
        return this._rejecting_providers.has(provider_id);
    }
    async ready() {
        let stack = this._stack;
        this._expires = dayjs_1.default.utc().add(this._conf.timeout, "ms");
        let market_client = await this._api_config.market();
        this._market_api = new rest.Market(market_client);
        let activity_client = await this._api_config.activity();
        this._activity_api = new rest.Activity(activity_client);
        let payment_client = await this._api_config.payment();
        this._payment_api = new rest.Payment(payment_client);
        await stack.enter_async_context(this._wrapped_consumer);
        return this;
    }
    async done() {
        utils_1.logger.debug("Executor is shutting down...");
        while (this._active_computations > 0) {
            utils_1.logger.debug(`Waiting for ${this._active_computations} computation(s)...`);
            await utils_1.promisify(csp.takeAsync)(this._chan_computation_done);
            this._active_computations -= 1;
        }
        utils_1.logger.debug("Executor shut down.");
        this._market_api = null;
        this._payment_api = null;
        await this._stack.aclose();
    }
}
exports.Executor = Executor;
//# sourceMappingURL=index.js.map