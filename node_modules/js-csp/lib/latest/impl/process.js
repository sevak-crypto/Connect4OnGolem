import { doAlts } from './select';
import { FnHandler } from './handlers';
import { TakeInstruction, PutInstruction, SleepInstruction, AltsInstruction } from './instruction';
import { Box } from './boxes';
import { Channel } from './channels';
import { queueDelay } from './dispatch';

export const NO_VALUE = '@@process/NO_VALUE';

export function putThenCallback(channel, value, callback) {
  const result = channel.put(value, new FnHandler(true, callback));

  if (result && callback) {
    callback(result.value);
  }
}

export function takeThenCallback(channel, callback) {
  const result = channel.take(new FnHandler(true, callback));

  if (result && callback) {
    callback(result.value);
  }
}

export function take(channel) {
  return new TakeInstruction(channel);
}

export function put(channel, value) {
  return new PutInstruction(channel, value);
}

export function sleep(msecs) {
  return new SleepInstruction(msecs);
}

export function alts(operations, options) {
  return new AltsInstruction(operations, options);
}

export function poll(channel) {
  if (channel.closed) {
    return NO_VALUE;
  }

  const result = channel.take(new FnHandler(false));

  return result ? result.value : NO_VALUE;
}

export function offer(channel, value) {
  if (channel.closed) {
    return false;
  }

  const result = channel.put(value, new FnHandler(false));

  return result instanceof Box;
}

export class Process {

  constructor(gen, onFinishFunc) {
    this.schedule = nextState => {
      setImmediate(() => this.run(nextState));
    };

    this.gen = gen;
    this.finished = false;
    this.onFinishFunc = onFinishFunc;
  }

  run(state) {
    if (!this.finished) {
      // TODO: Shouldn't we (optionally) stop error propagation here (and
      // signal the error through a channel or something)? Otherwise the
      // uncaught exception will crash some runtimes (e.g. Node)
      const { done, value } = this.gen.next(state);

      if (done) {
        this.finished = true;
        this.onFinishFunc(value);
      } else if (value instanceof TakeInstruction) {
        takeThenCallback(value.channel, this.schedule);
      } else if (value instanceof PutInstruction) {
        putThenCallback(value.channel, value.value, this.schedule);
      } else if (value instanceof SleepInstruction) {
        queueDelay(this.schedule, value.msec);
      } else if (value instanceof AltsInstruction) {
        doAlts(value.operations, this.schedule, value.options);
      } else if (value instanceof Channel) {
        takeThenCallback(value, this.schedule);
      } else {
        this.schedule(value);
      }
    }
  }
}